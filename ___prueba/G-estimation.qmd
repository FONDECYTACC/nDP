---
title: "G estimation"
format: html
editor: visual
---

```{css zoom-lib-src, echo = FALSE}
script src = "https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"
```

```{js zoom-jquery, echo = FALSE}
 $(document).ready(function() {
    $('body').prepend('<div class=\"zoomDiv\"><img src=\"\" class=\"zoomImg\"></div>');
    // onClick function for all plots (img's)
    $('img:not(.zoomImg)').click(function() {
      $('.zoomImg').attr('src', $(this).attr('src')).css({width: '100%'});
      $('.zoomDiv').css({opacity: '1', width: 'auto', border: '1px solid white', borderRadius: '5px', position: 'fixed', top: '50%', left: '50%', marginRight: '-50%', transform: 'translate(-50%, -50%)', boxShadow: '0px 0px 50px #888888', zIndex: '50', overflow: 'auto', maxHeight: '100%'});
    });
    // onClick function for zoomImg
    $('img.zoomImg').click(function() {
      $('.zoomDiv').css({opacity: '0', width: '0%'}); 
    });
  });
  
```

```{css hideOutput-lib-src, echo = FALSE}
<script src="hideOutput.js"></script> 
```

```{js hideOutput, echo = FALSE}
$(document).ready(function() {    
	$chunks = $('.fold');    
	$chunks.each(function () {      // add button to source code chunks     
	if ( $(this).hasClass('s') ) {       
		$('pre.r', this).prepend("<div class=\"showopt\">Show Source</div><br style=\"line-height:22px;\"/>");
       		$('pre.r', this).children('code').attr('class', 'folded');     
       		}      // add button to output chunks     
		if ( $(this).hasClass('o') ) {       
			$('pre:not(.r)', this).has('code').prepend("<div class=\"showopt\">Show Output</div><br style=\"line-height:22px;\"/>");       
			$('pre:not(.r)', this).children('code:not(r)').addClass('folded');        // add button to plots       
			$(this).find('img').wrap('<pre class=\"plot\"></pre>');       
			$('pre.plot', this).prepend("<div class=\"showopt\">Show Plot</div><br style=\"line-height:22px;\"/>");       
			$('pre.plot', this).children('img').addClass('folded');      
			}   
});    // hide all chunks when document is loaded   
	$('.folded').css('display', 'none')    // function to toggle the visibility   
	$('.showopt').click(function() {     
			var label = $(this).html();     
			if (label.indexOf("Show") >= 0) {       
				$(this).html(label.replace("Show", "Hide"));     
			} else {
			  $(this).html(label.replace("Hide", "Show"));     
			}     
	$(this).siblings('code, img').slideToggle('fast', 'swing');   
	}); 
}); 

```

```{=html}
<style type="text/css">
.showopt {   
  background-color: #004c93;   color: #FFFFFF;    width: 100px;   height: 20px;   text-align: center;   vertical-align: middle !important;   float: right;   font-family: sans-serif;   border-radius: 8px; 
  }  
.showopt:hover {     
        background-color: #dfe4f2;
        color: #004c93; 
        }  
pre.plot {   
        background-color: white !important; 
        } 
.tablelines table, .tablelines td, .tablelines th {
        border: 1px solid black;
        }
.centrado {
    text-align: center;
}
.table.center {
    margin-left:auto; 
    margin-right:auto;
  }
.table_wrapper{
    display: block;
    overflow-x: auto;
    white-space: nowrap;
}
code.r{
  font-size: 8px;
}
body{ /* Normal  */
      text-align: justify;
  }
.superbigimage{
    overflow-y:scroll;
    white-space: nowrap;
}
.superbigimage img{
    overflow-y: scroll;
    overflow-x: hidden;
}
</style>
```
```{=html}
<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px; text-align: justify;}
</style>
```
```{=html}
<!-- We gotta do each function to hide code and outputs per section, by every ID, we gotta create a different function -->
<script>
function myFunction1() {
    var x = document.getElementById("myDIV");
    if (x.style.display === "none") {
        x.style.display = "block";
    } else {
        x.style.display = "none";
    }
}
</script>

<script>
function myFunction2() {
    var x = document.getElementById("myDIV2");
    if (x.style.display === "none") {
        x.style.display = "block";
    } else {
        x.style.display = "none";
    }
}
</script>
```
```{r prev_setup, include = FALSE, cache=T}
rm(list=ls());gc()
if(!grepl("4.1.2",R.version.string)){stop("Different version (must be 4.1.2)")}
path<-rstudioapi::getSourceEditorContext()$path

if (grepl("CISS Fondecyt",path)==T){
  setwd("C:/Users/CISS Fondecyt/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/");load("C:/Users/CISS Fondecyt/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_5_apr22.RData")
} else if (grepl("andre",path)==T){
  setwd('C:/Users/andre/Desktop/SUD_CL/');load("E:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_5_apr22.RData")
} else if (grepl("E:",path)==T){
  setwd("E:/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/");load("E:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_5_apr22.RData")
} else {
  setwd("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/");load("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_5_apr22.RData")
}
```

```{r setup, include = FALSE, cache=T, error=T, echo=T}
#Libraries used in the routine. Dont change the order
local({r <- getOption("repos")
       r["CRAN"] <- "http://cran.r-project.org" 
       options(repos=r)
})
copiar_nombres <- function(x,row.names=FALSE,col.names=TRUE,dec=",",...) {
  if(class(ungroup(x))[1]=="tbl_df"){
        if(options()$OutDec=="."){
            options(OutDec = dec)
            write.table(format(data.frame(x)),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ".")
          return(x)
        } else {
            options(OutDec = ",")
            write.table(format(data.frame(x)),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ",")
          return(x)    
        }
  } else {
        if(options()$OutDec=="."){
            options(OutDec = dec)
            write.table(format(x),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ".")
          return(x)
        } else {
            options(OutDec = ",")
            write.table(format(x),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ",")
          return(x)       
  }
 }
} 
Sys.setenv("QUARTO_CMD"=rmarkdown::find_pandoc()$dir)

if(!require(pacman)){install.packages("pacman")}
pacman::p_load(APCtools, ggpattern, withr, boot, matrixStats, knitr, tidyr, stringi,stringr, ggplot2, Hmisc, kableExtra, plotly, janitor, rbokeh, zoo, broom, sqldf, devtools, codebook, data.table, panelr, RColorBrewer, lsmeans, finalfit, ggiraph, sf, treemapify, dplyr, tidyverse, epiR, survminer, ggfortify, survMisc, foreign, reshape2, stargazer, tableone, MatchIt, cobalt, eha, igraph, Amelia, DiagrammeR, DiagrammeRsvg, rsvg, mstate, htmltools, webshot, flexsurv, muhaz, Metrics, rpivotTable, caret, polycor, ClusterR, flextable, ggstatsplot, ggside, daff, explore, sjPlot, compareGroups, job, missForest, showtext, ggpattern, distill, showtext, confoundr,quarto, install=F)
try(webshot::install_phantomjs())

options(scipen=6) #display numbers rather scientific number

#remotes::install_github("chjackson/flexsurv-dev", upgrade = "never")
#devtools::install_github("stulacy/multistateutils", build_vignettes=TRUE, upgrade = "never")
#devtools::install_github("hputter/mstate", upgrade = "never")

#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

fitstats.flexsurvreg = function(x){
  ll = x$loglik
  aic = x$AIC
  k = length(x$coefficients)
  n = sum(x$data$m["(weights)"])
  aicc = aic + ((2 * k) * (k + 1) / (n - k - 1))
  bic = - 2 * ll + (k * log(n))
  data.frame(
   Df = k,
    "n2ll" = -2 * ll,
    AIC = aic,
    AICc = aicc,
    BIC = bic
  )
}


if(.Platform$OS.type == "windows") withAutoprint({
  memory.size()
  memory.size(TRUE)
  memory.limit()
})
memory.limit(size=56000)
```

## Ejemplo con confoundr

Primero formateo la base de datos para distinguir la censura `s` de la exposiciÃ³n `a`

```{r}
library(confoundr)
#data("example_sml")

d_match_surv_msprep_mod<-
d_match_surv_msprep %>% 
  plyr::rename(c("Readmission_status"="s_0","Readmission2_status"="s_1",
                 "Readmission3_status"="s_2","Readmission4_status"="s_3",
                 "tipo_de_plan_res_1"="a_0","tipo_de_plan_res_2"="a_1",
                 "tipo_de_plan_res_3"="a_2","tipo_de_plan_res_4"="a_3",
                 "TD_1"="l_0","TD_2"="l_1","TD_3"="l_2","TD_4"="l_3")) %>% 
  dplyr::mutate(h_0="H", h_1=ifelse(a_0==1,"H1","H0"), 
                h_1=dplyr::case_when(a_1==1~paste0(h_0,"1"),
                                     a_1==0~paste0(h_0,"0"),
                                     T~paste0(h_0,"0")),
                h_2=dplyr::case_when(a_2==1~paste0(h_1,"1"),
                                     a_2==0~paste0(h_1,"0"),
                                     T~paste0(h_1,"0")),
                h_3=dplyr::case_when(a_2==1~paste0(h_2,"1"),
                                     a_2==0~paste0(h_2,"0"),
                                     T~paste0(h_2,"0"))) %>% 
  dplyr::mutate(across(paste0("s_",0:3),~if_else(.x==1,0,1,1), # da lo mismo si se le pone NA_real_ en vez de 1 en caso de perdido
               .names = 'post_{col}')) %>% 
  plyr::rename(c("post_s_0"="c_0","post_s_1"="c_1","post_s_2"="c_2","post_s_3"="c_3"))

invisible("Es lo mismo solo que este me pone como NA a quellos que no tienen la misma cantidad de seguimientos")
mydata.history <- makehistory.one(input=d_match_surv_msprep %>% 
  plyr::rename(c("Readmission_status"="s_0","Readmission2_status"="s_1",
                 "Readmission3_status"="s_2","Readmission4_status"="s_3",
                 "tipo_de_plan_res_1"="a_0","tipo_de_plan_res_2"="a_1",
                 "tipo_de_plan_res_3"="a_2","tipo_de_plan_res_4"="a_3",
                 "TD_1"="l_0","TD_2"="l_1","TD_3"="l_2","TD_4"="l_3")),
                                  id="id",
                                  exposure="a",
                                  name.history="h",
                                  times=c(0,1,2,3))

d_match_surv_msprep_mod_l<-
lengthen(d_match_surv_msprep_mod, 
         diagnostic=2,#diagnostic of interest e.g. 1, 2, or 3= 
         censoring="yes", 
         id="id", 
         times.exposure=0:3, 
         times.covariate=0:3,
         exposure="a", 
         temporal.covariate=c("l"), 
         static.covariate = NULL,
         history = "h", 
         weight.exposure = NULL, 
         censor = "s",
         weight.censor = NULL, 
         strata = NULL)
mydata.history_l<-
lengthen(d_match_surv_msprep_mod, 
         diagnostic=2,#diagnostic of interest e.g. 1, 2, or 3= 
         censoring="yes", 
         id="id", 
         times.exposure=0:3, 
         times.covariate=0:3,
         exposure="a", 
         temporal.covariate=c("l"), 
         static.covariate = NULL,
         history = "h", 
         weight.exposure = NULL, 
         censor = "s",
         weight.censor = NULL, 
         strata = NULL)

invisible("sÃ³lo funciona para opc. 2")

table.std <- balance(input=d_match_surv_msprep_mod_l,
  diagnostic=2,
  approach="none",
  censoring="no",
  scope="average",
  average.over="distance",
  ignore.missing.metric="no",
  times.exposure=c(0,1,2,3),
  times.covariate=c(0,1,2,3),
  exposure="a",
  history="h"
) 
table.std2 <- balance(input=mydata.history_l,
  diagnostic=2,
  approach="none",
  censoring="yes",
  scope="average",
  average.over="distance",
  ignore.missing.metric="yes",
  times.exposure=c(0,1,2,3),
  times.covariate=c(0,1,2,3),
  exposure="a",
  history="h"
) 
table.std3 <- balance(input=mydata.history_l,
  diagnostic=2,
  approach="none",
  censoring="yes",
  scope="average",
  average.over="distance",
  ignore.missing.metric="yes",
  times.exposure=c(0,1,2,3),
  times.covariate=c(0,1,2,3),
  exposure="a",
  history="h"
) 
invisible("Diagnostic 2 assesses whether there is feedback between exposures and confounders over time. If present, it indicates the use of g-methods to control for time-varying confounding for any definition of time-varying exposure that is explicitly or implicitly multivariate (e.g., ever use at time $t$). The diagnostic examines whether the covariate mean differs across prior exposure groups, after adjustment for covariates (that precede the exposure) through inverse probability weighting or propensity score stratification.")
print(table.std)
sum(table(d_match_surv_msprep$duplicates_filtered)[2:8])

```

### DiagnÃ³stico 1

El primer diagnÃ³stico busca examinar si el promedio de la covariable anterior ($l_{k-1}$) es el mismo en grupos de exposiciÃ³n, entre personas que han seguido una trayectoria de exposiciÃ³n particular hasta un punto en el tiempo. Busca describir si los grupos de exposiciÃ³n han tenido distintas distribuciones de covariables anteriores.

Para diagnosticar 1 cualquiera sea no asumiendo censura

```{r}
d1_noc<-
diagnose(input=d_match_surv_msprep_mod,
         diagnostic=1,
         censoring="no",
         approach="none",
         scope="all",
         id="id",
         times.exposure=c(0,1,2,3),
         times.covariate=c(0,1,2,3),
         exposure="a",
         temporal.covariate=c("l"),
         history="h",
         ignore.missing.metric="no",
         loop="yes",
         sd.ref="no")
d1_noc %>% knitr::kable("markdown")
```

Ahora asumiendo censura

```{r}
d1_c<-
diagnose(input=d_match_surv_msprep_mod,#[,-"c_3"]
         diagnostic=1,
         censoring="yes",
         approach="none",
         scope="all",
         id="id",
         times.exposure=c(0,1,2,3),
         times.covariate=c(0,1,2,3),
         exposure="a",
         censor="c",
         temporal.covariate=c("l"),
         history="h",
         ignore.missing.metric="no",
         loop="yes",
         sd.ref="no")
d1_c %>% knitr::kable("markdown")
```

Por lo visto, hay trayectorias que parecen bastante distintas dependiendo de la trayectoria de tratamiento Por ej., quienes no son readmitidos con posterioridad, pero tambiÃ©n los que sÃ³lo fueron admitidos a tratamientos ambulatorios (`H000`) paracen haber completado mayormente el tratamiento anterior. En cambio, quienes completaron el tratamiento ambulatorio a la base pero luego transitaron por 2 tratamientos residenciales (`H011`) parecen no haber completado los 2 tratamientos anteriores, pero sÃ­ el tercero. Respecto a quienes sÃ³lo fueron admitidos al tratamiento residencial a la base y luego transitan por 2 tratamientos ambulatorios (`H100`)

### DiagnÃ³stico 2

El segundo diagnÃ³stico busca chequear si hay retroalimentaciÃ³n entre exposiciÃ³n y confusor en el tiempo. De haberlo, indica el uso de mÃ©todos-g para controlar por confusores tiempo-dependientes para cualquier definiciÃ³n de exposiciÃ³n tiempo-dependiente que es implÃ­cita o explÃ­citamente multivariable. El diagnÃ³stico examina si un promedio de covariables ($l_k$) difiere entre grupos de exposiciÃ³n previa ($a_{k-1}$) despuÃ©s de ajustar por las covariables, mediante IPW o estratificaciÃ³n PS.

Para diagnosticar 2 cualquiera sea no asumiendo censura

```{r}
d2_c<-
diagnose(input=d_match_surv_msprep_mod,
         diagnostic=2,
         censoring="no",
         approach="none",
         scope="all",
         id="id",
         times.exposure=c(0,1,2,3),
         times.covariate=c(0,1,2,3),
         exposure="a",
         temporal.covariate=c("l"),
         history="h",
         ignore.missing.metric="no",
         loop="yes",
         sd.ref="no")

d2_c %>% knitr::kable("markdown")
```

Ahora asumiendo censura

```{r}
d2_c<-
diagnose(input=d_match_surv_msprep_mod,#[,-"c_3"]
         diagnostic=2,
         censoring="yes",
         approach="none",
         scope="all",
         id="id",
         times.exposure=c(0,1,2,3),
         times.covariate=c(0,1,2,3),
         exposure="a",
         censor="c",
         temporal.covariate=c("l"),
         history="h",
         ignore.missing.metric="no",
         loop="yes",
         sd.ref="no")
d2_c %>% knitr::kable("markdown")
```

Por lo visto no hay un desbalance tan importante de los valores promedio de las covariables dependiendo del tratamiento anterior.

### DiagnÃ³stico 3

El tercer diagnÃ³stico debe utilizarse cuando los investigadores han aplicado los diagnÃ³sticos anteriores y han decidido utilizar mÃ©todos-g para ajustar por confusiÃ³n/sesgo de selecciÃ³n. Por lo mismo, no se utilizarÃ¡ en este ejemplo.

## Ejemplo con DT reg

```{r}
#| label: fig-airquality
#| fig-cap: Temperature and ozone level.
#| warning: false
#| results: 'hide'
#| eval: FALSE

if(!require(DTRreg)){install.packages("DTRreg")}

set.seed(1)
# expit function
expit <- function(x) {1 / (1 + exp(-x))}
# sample size and parameters
n <- 1000
theta1 <- c(6.3, 1.5, -0.8, 0.1, 0.1)
theta2 <- c(4, 1.1, -0.2, -0.9, 0.6, -0.1)
lambda <- 1/300
p <- 0.9
beta <- 2
# covariates and treatment (X = patient information, A = treatment)
X1 <- runif(n, 0.1, 1.29)
X14 <- X1^4
A1 <- rbinom(n, size = 1, prob = expit(2*X1 - 1))
X2 <- runif(n, 0.9, 2)
X23 <- X2^3
A2 <- rbinom(n, size = 1, prob = expit(-2*X2 + 2.8))
delta <- rbinom(n, size = 1, prob = expit(2*X1 - 0.4))
eta2 <- rbinom(n, 1, prob = 0.8)
delta2 <- delta[eta2 == 1]
# survival time
logY2 <- logT2 <- theta2[1] + theta2[2]*X2[eta2 == 1] + theta2[3]*X23[eta2 == 1] 
+ theta2[4]*A2[eta2 == 1] + theta2[5]*A2[eta2 == 1]*X2[eta2 == 1] 
+ theta2[6]*X1[eta2 == 1] + rnorm(sum(eta2), sd = 0.3)
trueA2opt <- ifelse(theta2[4]*A2[eta2 == 1] 
                    + theta2[5]*A2[eta2 == 1]*X2[eta2 == 1] > 0, 1, 0)
logT2opt <- logT2 + (trueA2opt - A2[eta2 == 1])*(theta2[4]*A2[eta2 == 1] 
                                                 + theta2[5]*A2[eta2 == 1]*X2[eta2 == 1])
logT <- theta1[1] + theta1[2]*X1 + theta1[3]*X14 + theta1[4]*A1 
+ theta1[5]*A1*X1 + rnorm(n, sd = 0.3)
T1 <- exp(logT[eta2 == 1 & delta == 1]) - exp(logT2opt[delta2 == 1])
logT[eta2 == 1 & delta == 1] <- log(T1 + exp(logT2[delta2 == 1]))
# censoring time
C <- (- log(runif(n - sum(delta), 0, 1))/(lambda * exp(beta * X1[delta == 0])))^(1/p)
eta2d0 <- eta2[delta == 0]
C1 <- rep(NA, length(C))
C2 <- rep(NA, length(C))
for(i in 1:length(C))
{
  if(eta2d0[i] == 0){
    C1[i] <-  C[i]
    C2[i] <- 0
  }else{
    C1[i] <- runif(1, 0, C[i])
    C2[i] <- C[i] - C1[i]
  }
}
# observed survival time
Y2 <- rep(NA, n)
Y1 <- rep(NA, n)
Y2[delta == 0] <- C2
Y1[delta == 0] <- C1
Y1[delta == 1 & eta2 == 1] <- T1
Y1[delta == 1 & eta2 == 0] <- exp(logT[delta == 1 & eta2 == 0])
Y2[delta == 1 & eta2 == 0] <- 0
Y2[delta == 1 & eta2 == 1] <- exp(logT2[delta2 == 1])
logY <- log(Y1 + Y2)
logY2 <- log(Y2[eta2 == 1])
# data and run DWSurv
mydata <- data.frame(X1,X14,A1,X2,X23,A2,delta,Y1,Y2)

head(mydata) %>% 
  knitr::kable("markdown")
```

Para mis datos, deberÃ© asumir que "C" es un equivalente a tratamiento "en curso". Y a juzgar por el ejemplo, debo ocupar \`d_match_surv_msprep\` (wide). Aunque viendo la salida de cÃ³digo, me da la impresiÃ³n de que delta es una forma de censura por no seguir en los tratamientos. Ahora ver:

-   Por lo visto, para cada etapa se deben definir los tiempos (Y), los controles, el modelo predictor del tratamiento (da lo mismo que se repitan), el tf (modelo treatment-free),

-   Me queda la duda de la estructura de confusiÃ³n. sobre todo de treat.mod (cÃ³mo afecta al tratamiento

-   Ver si se pueden repetir los tÃ©rminos, por lo visto sÃ­. Auqneu no sÃ© cÃ³mo especificar el TF

-   DecidÃ­ meter todo al treat.mod, como predictor, pero quien sabe si no estoy sobreajustando. Ver si es mejor verlo con DAG

```{r}
#| eval: FALSE
mydata <- data.frame(X1,X14,A1,X2,X23,A2,delta,Y1,Y2)
mod_nocensoring <- DWSurv(time = list(~Y1, ~Y2), blip.mod = list(~X1, ~X2), 
  treat.mod = list(A1~X1, A2~X2), tf.mod = list(~X1 + X14, ~X2 + X23 + X1), 
  cens.mod = list(~delta, ~delta), var.estim = "asymptotic", data = mydata)
mod_nocensoring

mod_nocensoring2 <- DWSurv(time = list(~Readmission_time, ~Readmission2_time, ~Readmission3_time, ~Readmission4_time), blip.mod = list(~TD_1, ~TD_2, ~TD_3, ~TD_4), treat.mod = list(tipo_de_plan_res_1~1, tipo_de_plan_res_2~ tipo_de_plan_res_1+ TD_1, tipo_de_plan_res_3~tipo_de_plan_res_2+ TD_2, tipo_de_plan_res_4~ tipo_de_plan_res_3+ TD_3), tf.mod = list(~dias_treat_imp_sin_na_1, ~TD_1+ dias_treat_imp_sin_na_1, ~dias_treat_imp_sin_na_2+ TD_2, ~dias_treat_imp_sin_na_3+ TD_3), cens.mod = list(~Readmission_status, ~Readmission2_status, ~Readmission3_status, ~Readmission4_status), var.estim = "asymptotic", data = d_match_surv_msprep %>% dplyr::mutate_at(c("Readmission_status",paste0("Readmission",2:4,"_status")),~ifelse(.==0,1,0))) #d_match_surv_msprep[which(d_match_surv_msprep$id %in% 1:10000),])
mod_nocensoring2

```
