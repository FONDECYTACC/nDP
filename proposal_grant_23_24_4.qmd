---
title: "Polysubstance and tr. completion"
description: |
  Analyze the association between polysubstance at admission and tr. compleiton longitudinally along treatments, accounting for irregular observations.
date: "`r format(Sys.time(),'%B %d, %Y')`"
author: "Andrés González Santa Cruz"
format: 
  html:
    css: styles.scss
    code-fold: true
    embed-resources: true
    # include-in-header:
    #   - custom-styles.css
    #   - custom-scripts.js
---

```{css}
#| echo: false

body {
  font-family: 'Times New Roman', Times, serif;
}

```
# Setup

```{r}
#| message: false
#| include: true
#| warning: false

rm(list = ls()) 
folder_path <- ifelse(dir.exists("E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/"),
                      "E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/",
                      "G:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/")
load(paste0(folder_path,"an_grant_23_24_3.RData"))
```



# Packages

```{r}
#| class-output: center-table
#| message: false
#| include: true
#| warning: false

system("fc-cache -f -v")

if(!require(pacman)){install.packages("pacman");library(pacman)}
pacman::p_unlock(lib.loc = .libPaths()) #para no tener problemas reinstalando paquetes


if (getRversion() != "4.1.2") { stop("Requires R version 4.1.2. Actual: ", getRversion()) }


if(!require(geepack)){install.packages("geepack");library(geepack)}
if(!require(geeM)){install.packages("geeM");library(geeM)}
if(!require(tidyverse)){install.packages("tidyverse");library(tidyverse)}
if(!require(MASS)){install.packages("MASS");library(MASS)}
if(!require(geeasy)){install.packages("geeasy");library(geeasy)}
if(!require(MuMIn)){remotes::install_version("MuMIn", "1.46.0");library(MuMIn)}
if(!require(tableone)){install.packages("tableone");library(tableone)}
if(!require(knitr)){install.packages("knitr");library(knitr)}
if(!require(emmeans)){install.packages("emmeans");library(emmeans)}
if(!require(biostat3)){install.packages("biostat3");library(biostat3)}
if(!require(rms)){install.packages("rms");library(rms)}
if(!require(meta)){install.packages("meta");library(meta)}
try(if(!require(dmetar)){install.packages("dmetar");library(dmetar)})
if(!require(metafor)){install.packages("metafor");library(metafor)}
try(if(!require(extrafont)){install.packages("extrafont");library(extrafont)})
try(if(!require(showtext)){install.packages("showtext");library(showtext)})
try(if(!require(mice)){install.packages("mice");library(mice)})
try(if(!require(htmltools)){install.packages("htmltools");library(htmltools)})
if(!require(chisq.posthoc.test)){devtools::install_github("ebbertd/chisq.posthoc.test")}
if(!require(DescTools)){install.packages("DescTools")}
if(!require(vcd)){install.packages("vcd")}

try(extrafont::font_import(pattern = "Times New Roman", prompt = FALSE))
extrafont::loadfonts(device="win")
# Agregar la ruta a la fuente "Times New Roman"
font_add("Times New Roman", "C:/Windows/Fonts/times.ttf")

# Habilitar showtext para gráficos
showtext::showtext_auto()

#https://gist.github.com/avallecam/56af06f46e5544c3af0f46344df20989 
#https://stackoverflow.com/questions/49089476/any-updates-to-model-negative-binomial-distribution-data-with-gee-in-r
#https://www.rdocumentation.org/packages/geepack/versions/1.3.4/topics/geese
#https://stackoverflow.com/questions/13946540/negative-binomial-in-gee?rq=1


#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

summary2.geem <- function(object, exponentiate = FALSE, digits = 2, ...) {
  if (!is.list(object) || !"beta" %in% names(object)) {
    stop("Invalid object: Expected a model object with beta coefficients.")
  }
  
  # Initialize coefficients matrix
  Coefs <- matrix(NA, nrow = length(object$beta), ncol = 8)
  rownames(Coefs) <- object$coefnames
  colnames(Coefs) <- c("Term", "Estimates", "Model SE", "Robust SE", "Wald", "CI.lower", "CI.upper", "p.value")
  
  Coefs[, "Estimates"] <- object$beta
  
  # Handling the variance calculations
  naive <- is.null(object$var) || is.character(object$var) || any(diag(object$var) < 0)
  if (naive) {
    warning("Robust variance estimate not available or invalid. Using model-based SE.")
    Coefs[, "Robust SE"] <- sqrt(diag(object$naiv.var))
  } else {
    Coefs[, "Robust SE"] <- sqrt(diag(object$var))
  }
  
  Coefs[, "Model SE"] <- sqrt(diag(object$naiv.var))  # Model-based SE
  
  # Calculate Wald statistics
  Coefs[, "Wald"] <- Coefs[, "Estimates"] / Coefs[, "Robust SE"]
  
  # 95% CI calculations
  z_value <- qnorm((1 + 0.95) / 2)
  Coefs[, "CI.lower"] <- Coefs[, "Estimates"] - z_value * Coefs[, "Robust SE"]
  Coefs[, "CI.upper"] <- Coefs[, "Estimates"] + z_value * Coefs[, "Robust SE"]
  
  # P-value calculation
  Coefs[, "p.value"] <- round(2 * pnorm(-abs(Coefs[, "Wald"])), digits = 4)
  
  # Exponentiate estimates and CIs if specified
  if (exponentiate) {
    Coefs[, c("Estimates", "CI.lower", "CI.upper")] <- exp(Coefs[, c("Estimates", "CI.lower", "CI.upper")])
  }
  
  # Round numerical output
  decimal_format <- sprintf("%%1.%df", digits)
  
  Coefs[, c("Estimates", "Model SE", "Robust SE", "Wald", "CI.lower", "CI.upper")] <- round(Coefs[, c("Estimates", "Model SE", "Robust SE", "Wald", "CI.lower", "CI.upper")], digits = digits)
  Coefs[, c("Estimates", "Model SE", "Robust SE", "Wald", "CI.lower", "CI.upper")] <- sapply(Coefs[, c("Estimates", "Model SE", "Robust SE", "Wald", "CI.lower", "CI.upper")], function(col) {
    as.character(sprintf(decimal_format, as.numeric(col)))
  })
  # Convert matrix to data frame and keep row names
  result_df <- as.data.frame(Coefs)
  result_df[, "Term"] <- rownames(Coefs)
  row.names(result_df) <- NULL
  return(result_df)
}

#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

tidy_geese_model <- function(geese_model, conf.level = 0.95) {
  # Extract coefficients and their names
  coefficients <- geese_model$beta
  coefficient_names <- names(coefficients)
  
  # Extract variance of beta coefficients and compute standard errors
  variance_beta <- geese_model$vbeta
  std_errors <- sqrt(diag(variance_beta))
  
  # Calculate z-values and p-values
  z_values <- coefficients / std_errors
  p_values <- 2 * pnorm(-abs(z_values), lower.tail = TRUE)
  
  # Calculate confidence intervals
  alpha <- 1 - conf.level
  z <- qnorm(1 - alpha / 2)
  lower_ci <- coefficients - z * std_errors
  upper_ci <- coefficients + z * std_errors
  
  # Exponentiate coefficients and confidence intervals for odds ratios
  exp_coefficients <- exp(coefficients)
  exp_lower_ci <- exp(lower_ci)
  exp_upper_ci <- exp(upper_ci)
  
  # Create a tidy data frame
  tidy_data <- tibble::tibble(
    Term = coefficient_names,
    Estimate = exp_coefficients,
    Std.Error = std_errors,
    z.value = z_values,
    p.value = p_values,
    CI.Lower = exp_lower_ci,
    CI.Upper = exp_upper_ci
  ) %>% dplyr::mutate_at(c("Estimate", "Std.Error", "z.value", "CI.Lower","CI.Upper"),~sprintf("%1.2f",.))%>% dplyr::mutate_at(c("p.value"),~sprintf("%1.4f",.))
  
  return(tidy_data)
}

options(knitr.kable.NA = '')


#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      # record the current time before each chunk
      now <<- Sys.time()
    } else {
      # calculate the time difference after a chunk
      res <- ifelse(difftime(Sys.time(), now)>(60^2),difftime(Sys.time(), now)/(60^2),difftime(Sys.time(), now)/(60^1))
      # return a character string to show the time
      x<-ifelse(difftime(Sys.time(), now)>(60^2),paste("Time for this code chunk to run:", round(res,1), "hours"),paste("Time for this code chunk to run:", round(res,1), "minutes"))
      paste('<div class="message">', gsub('##', '\n', x),'</div>', sep = '\n')
    }
  }
}))
knitr::opts_chunk$set(time_it = TRUE)

#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

format_cells <- function(df, rows ,cols, value = c("italics", "bold", "strikethrough")){
  
  # select the correct markup
  # one * for italics, two ** for bold
  map <- setNames(c("*", "**", "~~"), c("italics", "bold", "strikethrough"))
  markup <- map[value]  
  
  for (r in rows){
    for(c in cols){
      
      # Make sure values are not factors
      df[[c]] <- as.character( df[[c]])
      
      # Update formatting
      df[r, c] <- ifelse(nchar(df[r, c])==0,"",paste0(markup, gsub(" ", "", df[r, c]), markup))
    }
  }
  
  return(df)
}
#To produce line breaks in messages and warnings
knitr::knit_hooks$set(
  error = function(x, options) {
    paste('\n\n<div class="alert alert-danger">',
          gsub('##', '\n', gsub('^##\ Error', '**Error**', x)),
          '</div>', sep = '\n')
  },
  warning = function(x, options) {
    paste('\n\n<div class="alert alert-warning">',
          gsub('##', '\n', gsub('^##\ Warning:', '**Warning**', x)),
          '</div>', sep = '\n')
  },
  message = function(x, options) {
    paste('<div class="message">',
          gsub('##', '\n', x),
          '</div>', sep = '\n')
  }
)

#_#_#_#_#_#_#_#_#_#_#_#_#_
invisible("Function to format CreateTableOne into a database")

as.data.frame.TableOne <- function(x, ...) {capture.output(print(x,
                                                                 showAllLevels = TRUE, varLabels = T,...) -> x)
  y <- as.data.frame(x)
  y$characteristic <- dplyr::na_if(rownames(x), "")
  y <- y %>%
    fill(characteristic, .direction = "down") %>%
    dplyr::select(characteristic, everything())
  rownames(y) <- NULL
  y}
#_#_#_#_#_#_#_#_#_#_#_#_#_
# Austin, P. C. (2009). The Relative Ability of Different Propensity 
# Score Methods to Balance Measured Covariates Between 
# Treated and Untreated Subjects in Observational Studies. Medical 
# Decision Making. https://doi.org/10.1177/0272989X09341755
smd_bin <- function(x,y){
  z <- x*(1-x)
  t <- y*(1-y)
  k <- sum(z,t)
  l <- k/2
  
  return((x-y)/sqrt(l))
  
}

#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_

counting_process_output<-
  function(object=NULL){
    broom::tidy(object$m, exponentiate=T, conf.int=T) %>% 
      dplyr::mutate(across(c("estimate","std.error","robust.se","statistic","conf.low","conf.high"),~sprintf("%1.2f",.))) %>% 
      dplyr::mutate(p.value= sprintf("%1.4f",p.value))
  }

#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

tidy_coxph <- function(model, conf.level = 0.95) {
  # Extract the coefficients (a named numeric vector)
  coefs <- model$coefficients
  
  # Compute robust standard errors from the robust variance matrix
  robust_se <- sqrt(diag(model$var))
  
  # Compute z statistics and two-sided p-values
  z <- coefs / robust_se
  p_value <- 2 * (1 - pnorm(abs(z)))
  
  # Compute the critical z value for the specified confidence level
  z_crit <- qnorm(1 - (1 - conf.level) / 2)
  
  # Exponentiate coefficients to get hazard ratios
  hazard_ratio <- exp(coefs)
  
  # Compute the lower and upper confidence intervals (exponentiated)
  lower_ci <- exp(coefs - z_crit * robust_se)
  upper_ci <- exp(coefs + z_crit * robust_se)
  
  # Build and return a tidy data frame
  result <- data.frame(
    term         = names(coefs),
    coef         = coefs,
    robust_se    = robust_se,
    hazard_ratio = hazard_ratio,
    lower_ci     = lower_ci,
    upper_ci     = upper_ci,
    z            = z,
    p_value      = p_value,
    stringsAsFactors = FALSE
  )
  
  return(result)
}

format_hr_ci <- function(tidy_table, digits = 2) {
  # Build a format string dynamically using the desired number of digits.
  fmt <- paste0("%.", digits, "f (%.", digits, "f, %.", digits, "f)")
  
  # Create the new column using sprintf to format each row.
  tidy_table$hr_ci <- with(tidy_table, sprintf(fmt, hazard_ratio, lower_ci, upper_ci))
  
  return(tidy_table)
}

#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:


if(.Platform$OS.type == "windows") withAutoprint({
  memory.size()
  memory.size(TRUE)
  memory.limit()
})
memory.limit(size=56000)
```

```{r flwchrt}
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: false

invisible("At the beginning is in wide format")
invisible("At the beginning is in wide format")

nrow(Base_fiscalia_v15f_grant_23_24_long)
#[1] 109756
length(unique(Base_fiscalia_v15f_grant_23_24_long$hash_key))
#[1] 85048


Base_fiscalia_v15f_grant_23_24_long |> 
    dplyr::filter(motivodeegreso_mod_imp %in% c("En curso", "Muerte", "Derivación")) |>
    (\(df) {
        print(message(paste0("Dead, Referrals, ongoing treatments, Entries: ", nrow(df))))
        print(message(paste0("Dead, Referrals, ongoing treatments, HASHs: ", nrow(distinct(df,hash_key)))))
        
    })()

Base_fiscalia_v15f_grant_23_24_long |> 
    dplyr::filter(!motivodeegreso_mod_imp %in% c("En curso", "Muerte", "Derivación")) |>
    (\(df) {
        print(message(paste0("Dead, Referrals, ongoing treatments, Entries: ", nrow(df))))
        print(message(paste0("Dead, Referrals, ongoing treatments, HASHs: ", nrow(distinct(df,hash_key)))))
        
    })()

length(unlist(unique(Base_fiscalia_v15f_grant_23_24_long2$hash_key)))
 
#[exclude ongoing treatments and external referrals]
length(unique(Base_fiscalia_v15f_grant_23_24$hash_key))

length(unique(Base_fiscalia_v15f_grant_23_24_long2$hash_key))
#72404
nrow(Base_fiscalia_v15f_grant_23_24_long2)
#[1] 90075
#
Base_fiscalia_v15f_grant_23_24_long2 |> 
    dplyr::filter(!hash_key %in% Base_fiscalia_v15f_grant_23_24_long2_miss_proc_multtr$hash_key
) |>
    (\(df) {
        print(message(paste0("Only one treatment: ", nrow(df))))
        print(message(paste0("Only one treatment: ", nrow(distinct(df,hash_key)))))
        
    })()
```


```{r flwchrt2}
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true
library(DiagrammeR)
gr<-
  grViz("
    digraph flowchart {
      graph [layout = dot, rankdir = TB]
    
      # General node styling
      node [fontname = Times, shape = rectangle, fontsize = 10, style = filled, fillcolor = transparent]
    
      # Main flow nodes
      original [label = 'Original C1 Dataset\\n(n = 163,146;\\nPatients = 85,722)', fillcolor = lightgray]
      c1_dataset [label = 'C1 Dataset\\n(n = 109,756;\\nPatients = 85,048)']
      after_discard [label = 'C1 Dataset\\n(n = 90,075;\\nPatients = 72,404)']
      final_dataset [label = 'Final C1 Dataset\\n(n = 30,988;\\nPatients = 13,317)', fillcolor = lightgray]
    
      # Discard nodes (aligned between main flow steps)
      discard_referrals [label = '&#8226;Discard external referrals or ongoing treatments\\l(n = 19,681; Patients = 18,450)\\l']
      discard_duplicates [label = '&#8226;Discard duplicated entries\\l&#8226;Intermediate events of treatment (continuous referrals)\\l']
      discard_single [label = '&#8226;Discard admitted to only one treatment(Patients = 59,087)\\l']
    
      # Invisible vertices for middle line
      v1 [shape = point, width = 0, style = invis]
      v2 [shape = point, width = 0, style = invis]
      v3 [shape = point, width = 0, style = invis]
    
      # Main flow edges (vertical line)
      original -> v1 [arrowhead = none]
      v1 -> c1_dataset
      c1_dataset -> v2 [arrowhead = none]
      v2 -> after_discard
      after_discard -> v3 [arrowhead = none]
      v3 -> final_dataset
    
      # Discard connections (from the middle line)
      v1 -> discard_referrals
      v2 -> discard_duplicates
      v3 -> discard_single
    
      # Alignment
      { rank = same; discard_referrals; v1 }
      { rank = same; discard_duplicates; v2 }
      { rank = same; discard_single; v3 }
    }
  ", 
  width = 1600,
  height = 1200)
gr

folder_path <- ifelse(dir.exists("E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/"),
                      "E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/",
                      "G:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/")
unlink(paste0(folder_path, "_doc/_flowchart_files"), recursive = TRUE)
htmlwidgets::saveWidget(gr, paste0(folder_path, "_doc/_flowchart.html"))
webshot::webshot(paste0(folder_path, "_doc/_flowchart.html"), 
                 paste0(folder_path, "_doc/_flowchart.png"),
                 vwidth = 300*1.2, vheight = 300,  zoom=10, expand=100)  # Prueba con diferentes coordenadas top, left, width, and height.

webshot::webshot(paste0(folder_path, "_doc/_flowchart.html"), 
                 paste0(folder_path, "_doc/_flowchart_fixed.png"),
                 vwidth = 1200,   # Ancho mayor para mejor resolución
                 vheight = 800,   # Alto suficiente para capturar todo
                 zoom = 20,        # Zoom alto para mejor calidad
                 expand = -250)     # Márgenes adicionales
```


## 0.a. Descriptives

```{r label-variables-desc}
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true

invisible("Las siguientes variables no eran de interés para mí y aposterior al análisis, pero sí se usaron para imputar: ")
#num_hijos_mod_joel_bin,
#tenencia_de_la_vivienda_mod
#macrozona
#tipo_centro_pub, origen_ingreso_mod,
#porc_pobr
#clas_r
#con_quien_vive_joel
#edad_ini_cons
nonimputed_data_with_final_hashs_complete_cases<-
subset(Base_fiscalia_v15f_grant_23_24_long2, hash_key %in% unique(Base_fiscalia_v15f_grant_23_24_long2_miss_proc_multtr$hash_key))[which(complete.cases(subset(Base_fiscalia_v15f_grant_23_24_long2, hash_key %in% unique(Base_fiscalia_v15f_grant_23_24_long2_miss_proc_multtr$hash_key), select= c(hash_key, tipo_de_plan_2, tipo_de_plan_2_mod, sex,  edad_al_ing_1,  escolaridad_rec, sus_principal_mod, freq_cons_sus_prin_ord, condicion_ocupacional_corr24, policonsumo, policonsumo2, dg_cie_10_rec, dg_trs_cons_sus_or, sus_ini_mod_mvv, ano_nac_corr,  compromiso_biopsicosocial,compromiso_biopsicosocial.y)))),] |> nrow()

paste0("Percentage of the total that had complete values: ",
scales::percent(nonimputed_data_with_final_hashs_complete_cases/nrow(subset(Base_fiscalia_v15f_grant_23_24_long2, hash_key %in% unique(Base_fiscalia_v15f_grant_23_24_long2_miss_proc_multtr$hash_key))), accuracy = 0.1)
, "; total= ", format(nrow(subset(Base_fiscalia_v15f_grant_23_24_long2, hash_key %in% unique(Base_fiscalia_v15f_grant_23_24_long2_miss_proc_multtr$hash_key))),big.mark=","))
#27,460 x 39
#[1] "Percentage of the total that had complete values: 88.6%; total= 30,988"

missing_stats<-
subset(Base_fiscalia_v15f_grant_23_24_long2, 
       hash_key %in% unique(Base_fiscalia_v15f_grant_23_24_long2_miss_proc_multtr$hash_key), 
       select = c(hash_key, tipo_de_plan_2, tipo_de_plan_2_mod, sex,  edad_al_ing_1, escolaridad_rec, sus_principal_mod, freq_cons_sus_prin_ord, condicion_ocupacional_corr24, policonsumo, policonsumo2, dg_cie_10_rec, dg_trs_cons_sus_or, sus_ini_mod_mvv, ano_nac_corr,  compromiso_biopsicosocial,compromiso_biopsicosocial.y)) |> 
  (\(df) {
    data.frame(
      Variable = names(df),
      N_missing = colSums(is.na(df)),
      Percent_missing = round(colMeans(is.na(df)) * 100, 2)
    )
  })() |> 
  (\(stats) stats[order(-stats$Percent_missing), ])()|> 
  data.table::data.table()
#                         Variable N_missing Percent_missing
#                           <char>     <num>           <num>
#  1:  tenencia_de_la_vivienda_mod      1965            6.34
#  2:    compromiso_biopsicosocial       569            1.84
#  3:  compromiso_biopsicosocial.y       571            1.84
#  4:                edad_ini_cons       411            1.33
#  5:              sus_ini_mod_mvv       344            1.11
#  6:       num_hijos_mod_joel_bin       207            0.67
#  7:       freq_cons_sus_prin_ord       149            0.48
#  8:              escolaridad_rec       102            0.33
#  9:           tipo_de_plan_2_mod        63            0.20
# 10:               tipo_de_plan_2        41            0.13

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

invisible("2024-05-21: test number of treatments")
subset(Base_fiscalia_v15f_grant_23_24_long2_miss_proc_multtr, is_first_occurrence==T)  |> 
    dplyr::summarise(min= min(n), mean= mean(n), sd= sd(n), p25= quantile(n, .25), p50= quantile(n, .5), p75= quantile(n, .75), p77= quantile(n, .77), p89= quantile(n, .89), max= max(n))
#   min     mean       sd p25 p50 p75 p77 p89 max
# 1   2 2.326951 0.679621   2   2   2   3   3  10

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
invisible("2024-05-21: test different")
data_mine_miss_restr_proc2exp<-
data_mine_miss_restr_proc2 %>% 
left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","n_off_acq","n_off_vio","n_off_sud","n_off_oth", "n_prev_off")], by="hash_key") %>% 
  {if (nrow(.) > nrow(data_mine_miss_restr_proc2)) {message("left join added rows"); .} else .} %>% 
  dplyr::mutate(n_prev_off_bin= ifelse(n_prev_off>0,1,0)) %>% 
  dplyr::mutate(
    susinidumrec_coc = ifelse(sus_ini_mod_mvv == "Cocaine hydrochloride", 1, 0),
    susinidumrec_pbc = ifelse(sus_ini_mod_mvv == "Cocaine paste", 1, 0),
    susinidumrec_mar = ifelse(sus_ini_mod_mvv == "Marijuana", 1, 0),
    susinidumrec_otr = ifelse(sus_ini_mod_mvv == "Other", 1, 0), #sus_principal_mod
    susprindumrec_coc = ifelse(sus_principal_mod == "Cocaine hydrochloride", 1, 0),
    susprindumrec_pbc = ifelse(sus_principal_mod == "Cocaine paste", 1, 0),
    susprindumrec_mar = ifelse(sus_principal_mod == "Marijuana", 1, 0),
    susprindumrec_otr = ifelse(sus_principal_mod == "Other", 1, 0) # "susprindum_coc", "susprindum_pbc", "susprindum_mar", "susprindum_oh
  )

#"susinidumrec_otr", "susinidum_coc", "susinidum_pbc", "susinidum_mar",

  #janitor::tabyl(n_off_acq)

#(Post-Treatment)
# n_post_off_acq
# n_post_off_vio
# n_post_off_sud
# n_post_off_ot
# n_post_off

invisible("To account for variability by treatment setting, we stratified the analysis by setting: basic ambulatory GP intensive ambulatory GP residential WO intensive ambulatory WO residential")
table(subset(Base_fiscalia_v15f_grant_23_24_long2_miss_proc_multtr, is_first_occurrence==1, select= "tipo_de_plan_2_mod"))

data_mine_miss_restr_proc2exp %>% 
  group_by(hash_key) %>% 
  summarise(min(fech_ing_num)) %>% nrow()
#13317
subset(data_mine_miss_restr_proc2 , is_first_occurrence==1) %>% nrow()
#13317
data_mine_miss_restr_proc2_baseline<-
  subset(data_mine_miss_restr_proc2exp , is_first_occurrence==1) 


variables_vector <- c("tr_outcome", "policonsumo2", "comp_bpsc_y3_severe", "less_90d_tr1", "log_dias_treat_imp_sin_na", "edad_al_ing_1", "ano_nac_corr", "susinidumrec_coc", "susinidumrec_pbc", "susinidumrec_mar", "susinidumrec_otr", "psycom_dum_study", "psycom_dum_with", "freq_cons_dum_5day", "cond_oc_dum_2inact", "cond_oc_dum_3unemp", "susprindumrec_coc", "susprindumrec_pbc", "susprindumrec_mar", "susprindumrec_otr")# ,"lag_comp_bpsc_y3_severe", "lag_less_90d_tr1", "log_lag_dias_treat_imp_sin_na", "lag_policonsumo2", "lag_tr_outcome")

```

```{r label-variables-desc2}
#| class-output: center-table
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true

attr(data_mine_miss_restr_proc2_baseline$tr_outcome,"label") <- "Complete status of treatment (binary)"
attr(data_mine_miss_restr_proc2_baseline$tr_outcome,"label") <- "Complete status of treatment (binary)"
attr(data_mine_miss_restr_proc2_baseline$policonsumo2,"label") <- "Polysubstance use"
attr(data_mine_miss_restr_proc2_baseline$comp_bpsc_y3_severe,"label") <- "Biopsychosocial compromise (Severe)"
attr(data_mine_miss_restr_proc2_baseline$less_90d_tr1,"label") <- "Treatment duration (binary) (<90 days)"
attr(data_mine_miss_restr_proc2_baseline$log_dias_treat_imp_sin_na,"label") <- "Treatment duration (log-scaled days)"
attr(data_mine_miss_restr_proc2_baseline$edad_al_ing_1,"label") <- "Age at admission to treatment"
attr(data_mine_miss_restr_proc2_baseline$ano_nac_corr,"label") <- "Birth year"
attr(data_mine_miss_restr_proc2_baseline$susinidumrec_coc,"label") <- "Primary substance (initial diagnosis): cocaine hydrochloride"
attr(data_mine_miss_restr_proc2_baseline$susinidumrec_pbc,"label") <- "Primary substance (initial diagnosis): cocaine base paste"
attr(data_mine_miss_restr_proc2_baseline$susinidumrec_mar,"label") <- "Primary substance (initial diagnosis): marijuana"
attr(data_mine_miss_restr_proc2_baseline$susinidumrec_otr,"label") <- "Primary substance (initial diagnosis): other"
attr(data_mine_miss_restr_proc2_baseline$psycom_dum_study,"label") <- "Psychiatric comorbidity (ICD-10): In study"
attr(data_mine_miss_restr_proc2_baseline$psycom_dum_with,"label") <- "Psychiatric comorbidity (ICD-10): Diagnosed"
attr(data_mine_miss_restr_proc2_baseline$freq_cons_dum_5day,"label") <- "Daily frequence of primary substance use at admission"
attr(data_mine_miss_restr_proc2_baseline$cond_oc_dum_2inact,"label") <- "Occupational Status: Inactive"
attr(data_mine_miss_restr_proc2_baseline$cond_oc_dum_3unemp,"label") <- "Occupational Status: Unemployed"
attr(data_mine_miss_restr_proc2_baseline$susprindumrec_coc,"label") <- "Primary substance at admission to treatment: cocaine hydrochloride"
attr(data_mine_miss_restr_proc2_baseline$susprindumrec_pbc,"label") <- "Primary substance at admission to treatment: cocaine base paste"
attr(data_mine_miss_restr_proc2_baseline$susprindumrec_mar,"label") <- "Primary substance at admission to treatment: marijuana"
attr(data_mine_miss_restr_proc2_baseline$susprindumrec_otr,"label") <- "Primary substance at admission to treatment: other"
attr(data_mine_miss_restr_proc2_baseline$tipo_de_plan_2_mod,"label") <- "Treatment setting"

invisible("Table for imputed dataset with selected covariates")

library(tableone)

vars <- setdiff(c(variables_vector,"tipo_de_plan_2_mod"), "policonsumo2")
factorVars <- setdiff(variables_vector, c("policonsumo2", "edad_al_ing_1", "log_dias_treat_imp_sin_na", "ano_nac_corr"))

tableOne <- CreateTableOne(vars = vars, data = data_mine_miss_restr_proc2_baseline,
                           factorVars = factorVars, strata = "policonsumo2", 
                           addOverall = TRUE,  # <-- This is the key addition
                           includeNA = TRUE,
                           test = TRUE) # Remove statistical tests for speed

#print(tableOne, smd = TRUE) # Calculate SMD separately if needed

smd_bin(
  prop.table(table(data_mine_miss_restr_proc2_baseline$susprindum_mar[data_mine_miss_restr_proc2_baseline$policonsumo==0]))[[2]],
  prop.table(table(data_mine_miss_restr_proc2_baseline$susprindum_mar[data_mine_miss_restr_proc2_baseline$policonsumo==1]))[[2]]
)
smd_bin(
    prop.table(table(data_mine_miss_restr_proc2_baseline$comp_bpsc_y3_severe [data_mine_miss_restr_proc2_baseline$policonsumo==0]))[[2]],
    prop.table(table(data_mine_miss_restr_proc2_baseline$comp_bpsc_y3_severe [data_mine_miss_restr_proc2_baseline$policonsumo==1]))[[2]]
)

folder_path <- ifelse(dir.exists("E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/"),
                      "E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/",
                      "C:/Users/CISS Fondecyt/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/")

as.data.frame.TableOne(tableOne, smd=T, nonnormal= T)%>% 
    dplyr::mutate(char2=characteristic) %>% 
    tidyr::fill(char2) %>% 
    dplyr::select(char2,everything()) %>% 
    dplyr::mutate(level=ifelse(is.na(level),"[Missing]",level)) %>% 
    dplyr::mutate(char2=dplyr::case_when(characteristic=="NA"~NA_character_,TRUE~as.character(characteristic))) %>% 
    format_cells(1, 1:length(names(.)), "bold") %>%
    dplyr::select(-1) %>% 
    dplyr::mutate_all(~ str_replace_all(., pattern = "\\( ", replacement = "\\(")) %>% 
    dplyr::mutate_all(~ str_trim(.)) %>% 
    dplyr::select(characteristic, level, `0`, `1`, Overall, SMD)%>% 
  {
    knitr::kable(.,size=10, format="html",caption= "Summary descriptives, Polysubstance(1) and no Polysubstance use (0)", escape=T)%>% 
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
     kableExtra::scroll_box(width = "100%", height = "375px")  
    write.table(.,paste0(folder_path,"baseline_psu_desc_subsamp_smd.csv"), dec=",", sep="\t")
  }
```

```{r exp-surv1}
#| class-output: center-table
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true

  rbind.data.frame(
    cbind.data.frame(
      type= "PSU at admission and at least one dropout from the first admission",
    biostat3::survRate(Surv(cens_time, sum_tr_outcomes>0) ~ policonsumo2, 
                       data= data_mine_miss_restr_proc2 %>% 
                        dplyr::group_by(hash_key) %>% 
                        dplyr::mutate(sum_tr_outcomes=sum(tr_outcome==1,na.rm=T)) %>% 
                        dplyr::filter(is_first_occurrence==1) %>% 
                        dplyr::ungroup())  %>% 
      dplyr::mutate(across(c("rate", "lower", "upper"),~sprintf("%1.2f",.*1000)))
    ),
    cbind.data.frame(
      type= "PSU at admission and first dropout",
    biostat3::survRate(Surv(cens_time, tr_outcome==1) ~ policonsumo2, 
                       data= data_mine_miss_restr_proc2 %>% 
                        dplyr::group_by(hash_key) %>% 
                        dplyr::mutate(sum_tr_outcomes=sum(tr_outcome==1,na.rm=T)) %>% 
                        dplyr::filter(is_first_occurrence==1) %>% 
                        dplyr::ungroup())  %>% 
      dplyr::mutate(across(c("rate", "lower", "upper"),~sprintf("%1.2f",.*1000))) 
    ),
    cbind.data.frame(
      type= "At least one treatment reporting PSU and at least one dropout from the first admission",
    biostat3::survRate(Surv(cens_time, sum_tr_outcomes>0) ~ policonsumo2, 
                       data= data_mine_miss_restr_proc2 %>% 
                        dplyr::group_by(hash_key) %>% 
                        dplyr::mutate(sum_tr_outcomes=sum(tr_outcome==1,na.rm=T),
                                      sum_policonsumo2=sum(policonsumo2==1,na.rm=T)) %>% 
                        dplyr::filter(is_first_occurrence==1) %>% 
                        dplyr::ungroup() %>% dplyr::mutate(policonsumo2=ifelse(sum_policonsumo2>0,1,0)))  %>% 
      dplyr::mutate(across(c("rate", "lower", "upper"),~sprintf("%1.2f",.*1000))) 
    ),
    cbind.data.frame(
      type= "At least one treatment reporting PSU and first dropout",
    biostat3::survRate(Surv(cens_time, tr_outcome==1) ~ policonsumo2, 
                       data= data_mine_miss_restr_proc2 %>% 
                        dplyr::group_by(hash_key) %>% 
                        dplyr::mutate(sum_tr_outcomes=sum(tr_outcome==1,na.rm=T),
                                      sum_policonsumo2=sum(policonsumo2==1,na.rm=T)) %>% 
                        dplyr::filter(is_first_occurrence==1) %>% 
                        dplyr::ungroup() %>% dplyr::mutate(policonsumo2=ifelse(sum_policonsumo2>0,1,0)))  %>% 
      dplyr::mutate(across(c("rate", "lower", "upper"),~sprintf("%1.2f",.*1000))) 
    )    
  ) %>%  
    dplyr::mutate(`IR (95% CI)`= paste0(rate, " (", lower,", ", upper,")")) %>% 
    dplyr::select(-any_of(c("rate", "lower", "upper"))) %>% 
    dplyr::mutate(across(c("tstop", "event"),~ format(as.numeric(.), big.mark=","))) %>% 
    
  {
    copiar_nombres2(.)
    write.table(.,paste0(folder_path,"person_time_irrs.csv"), dec=",", sep="\t")
    knitr::kable(.,"html", caption= "Incidence rates (per 1.000 person-months)")%>% 
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
     kableExtra::scroll_box(width = "100%", height = "375px")  
  }
```


```{r post-rev}
#| class-output: center-table
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true

#This finding suggests that the former group had a longer observation period in the database, potentially influencing the observed association, as shown in Table 2. 

#JRT- 2024-12-30
#Quizás esto se puede decir más concreto, "sabiendo que el tiempo de observación es mayor en el grupo..." Eso es un hecho? que ocurre en la base de datos?

data_mine_miss_restr_proc2 %>% 
                        dplyr::group_by(hash_key) %>% 
                        dplyr::mutate(sum_tr_outcomes=sum(tr_outcome==1,na.rm=T)) %>% 
                        dplyr::filter(is_first_occurrence==1) %>% 
                        dplyr::ungroup() |> 
  group_by(policonsumo2) |> count()
#   policonsumo2     n
#          <dbl> <int>
# 1            0  2383
# 2            1 10934

#161852.30/2383
#[1] 67.91956
#872863.25/10934
#[1] 79.83019
invisible("Razón PSU al ingreso y exposición por tiempo")
#79.83019/67.91956
#[1] 1.175364
#
scales::percent(1.175364-1)
#"18"
data_mine_miss_restr_proc2 %>% 
    dplyr::group_by(hash_key) %>% 
    dplyr::mutate(sum_tr_outcomes=sum(tr_outcome==1,na.rm=T),
                  sum_policonsumo2=sum(policonsumo2==1,na.rm=T)) %>% 
    dplyr::filter(is_first_occurrence==1) %>% 
    dplyr::ungroup() %>% dplyr::mutate(policonsumo2=ifelse(sum_policonsumo2>0,1,0)) |> 
    group_by(policonsumo2) |> 
    count()
#  policonsumo2     n
#          <dbl> <int>
# 1            0  1271
# 2            1 12046
#78926.85/1099
#955788.69/11121
#85.94449/71.81697
invisible("Razón PSU al ingreso y no completar")
#1.196716
scales::percent(1.196716-1)
#
invisible("Prevalencia; al menos un no-completar, con PSU al ingreso")
scales::percent(2135/2383) #90%
invisible("Prevalencia; al menos un no-completar, con PSU al ingreso")
scales::percent(10085/10934) #92%
invisible("Prevalencia; no completar el primer tto., con PSU al ingreso")
scales::percent(1833/2383) #77%
invisible("Prevalencia; no completar el primer tto., con PSU al ingreso")
scales::percent(8615/10934) #79%
invisible("Prevalencia; al menos un no-completar, sin PSU alguna vez")
scales::percent(1099/1271) #86%
invisible("Prevalencia; al menos un no-completar, con PSU alguna vez")
scales::percent(11121/12046) #92%
invisible("Prevalencia; no completar el primer tto., sin PSU lguna vez")
scales::percent(936/1271) #74%
invisible("Prevalencia; no completar el primer tto., con PSU alguna vez")
scales::percent(9512/12046) #79%

```


## 0.b. IIWs

```{r iiw-summary}
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true

rbind.data.frame(
  cbind.data.frame(model= "Primary (no corrections, lag=0)", t(matrix(summary(data_mine_miss_restr_proc2$iiw_nocorr_st)))),
  cbind.data.frame(model= "Alternative (no corrections, lag=1)", t(matrix(summary(data_mine_miss_restr_proc2$iiw_nocorr_alt_st)))),
  cbind.data.frame(model= "Primary (after PH, lag=0)", t(matrix(summary(data_mine_miss_restr_proc2_iiw_after_ph$iiw_after_ph_st)))),
  cbind.data.frame(model= "Alternative (after PH, lag=1)", t(matrix(summary(data_mine_miss_restr_proc2_iiw_after_ph_alt$iiw_after_ph_st)))),
  cbind.data.frame(model= "Primary (strata, lag=0)", t(matrix(summary(data_mine_miss_proc2_iiw_strata_alt$iiw_strata_st)))),
  cbind.data.frame(model= "Alternative (strata, lag=1)", t(matrix(summary(data_mine_miss_proc2_iiw_strata_alt_alt$iiw_strata_st))))
) %>%  #Min.	First quartile	Median	Mean	Third quartile	Max.
  dplyr::mutate_if(is.numeric, ~sprintf("%1.2f",.)) %>% 
  dplyr::mutate(model= dplyr::case_when(model== "Primary (no corrections, lag=0)"~ "No time-varying coefficients, lagged covariates fixed in 0", model== "Alternative (no corrections, lag=1)"~ "No time-varying coefficients, lagged covariates fixed in 1", model== "Primary (after PH, lag=0)"~ "With time-varying coefficients, lagged covariates fixed in 0", model== "Alternative (after PH, lag=1)"~ "With time-varying coefficients, lagged covariates fixed in 1", model== "Primary (strata, lag=0)"~ "Stratified by follow-up intervals, lagged covariates fixed in 0", model== "Alternative (strata, lag=1)"~ "Stratified by follow-up intervals, lagged covariates fixed in 1")) %>% 
  {
    write.table(.,paste0(folder_path,"iiws_20240516.csv"), dec=",", sep="\t")
    knitr::kable(.,size=10, format="html",caption= "Descriptive characterization of inverse intensity weights", escape=T, col.names= c("Visit intensity model", "Min.",	"First quartile",	"Median",	"Mean",	"Third quartile",	"Max."))%>% 
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
     kableExtra::scroll_box(width = "100%", height = "375px")  
  }
```


## 0.c. Intensity model

```{r intensity-model}
#| class-output: center-table
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true
#Cox Counting process


#https://rdrr.io/github/gforge/Greg/src/R/tidy.rms.R
source(paste0(folder_path,"tidy_rms.R"))

term_mapping <- data.frame(
  term = c("lag_tr_outcome", "lag_comp_bpsc_y3_severe", "lag_less_90d_tr1", "log_lag_dias_treat_imp_sin_na", "lag_policonsumo2", "edad_al_ing_1", "ano_nac_corr", "susinidumrec_coc", "susinidumrec_pbc", "susinidumrec_mar", "susinidumrec_otr", "psycom_dum_study", "psycom_dum_with", "freq_cons_dum_5day", "cond_oc_dum_2inact", "cond_oc_dum_3unemp", "susprindumrec_coc", "susprindumrec_pbc", "susprindumrec_mar", "susprindumrec_otr",  "lag_tr_outcome_rec", "lag_less_90d_tr1_rec", "lag_comp_bpsc_y3_severe_rec", "susinidum_coc_rec2", "psycom_dum_with_rec2"),
  term_label = c("Treatment outcome of the previous treatment", "Previous biopsychosocial compromise (severe)", 
                 "Previous treatment duration (<90 days)", "Previous treatment duration (in logarithmic scaled days)", 
                 "Polysubstance use status of the previous treatment", "Age at admission to treatment", "Birth year", 
                  "Primary substance (initial diagnosis), cocaine", "Primary substance (initial diagnosis), cocaine base paste", "Primary substance (initial diagnosis), marijuana", "Primary substance (initial diagnosis), other", "Psychiatric comorbidity (diagnosis unknown or under study)", "Psychiatric comorbidity (confirmed comorbidity)", "Daily frequence of primary substance use at admission", "Occupational status (inactive)", "Occupational status (unemployed)", "Primary substance at admission to treatment (cocaine hydrochloride)", "Primary substance at admission to treatment (cocaine base paste)", "Primary substance at admission to treatment (marijuana)", "Primary substance at admission to treatment (other)", "Treatment outcome of the previous treatment (recoded for interaction with time)", "Previous biopsychosocial compromise (severe, recoded for interaction with time)", "Previous treatment duration (<90 days, recoded for interaction with time)", "Primary substance (initial diagnosis), cocaine (recoded for interaction with time)", "Psychiatric comorbidity (confirmed comorbidity, recoded for interaction with time)")
)

cph_nocorr<-
  cph(Surv(lag_time,time,event)~
        cluster(id)+ 
        lag_tr_outcome+
        lag_comp_bpsc_y3_severe+
        lag_less_90d_tr1+
        log_lag_dias_treat_imp_sin_na +
        lag_policonsumo2 + 
        edad_al_ing_1 + 
        ano_nac_corr + 
        susinidumrec_otr +
        susinidumrec_coc +
        susinidumrec_pbc +
        susinidumrec_mar +
        psycom_dum_study +
        psycom_dum_with +
        freq_cons_dum_5day +
        cond_oc_dum_2inact +
        cond_oc_dum_3unemp +
        susprindumrec_coc +
        susprindumrec_pbc +
        susprindumrec_mar +
        susprindumrec_otr +    
        strat(tipo_de_plan_2_mod),
      data= data_mine_miss_restr_proc2exp %>% data.table::as.data.table() %>% data.frame(), 
      x=TRUE, y=TRUE, surv=TRUE, iter.max = 250*4, tol = 1e-6)

cph_after_ph<-
cph(Surv(lag_time,time,event==1)~ 
                  cluster(id)+ 
                  lag_tr_outcome_rec +
                  log_lag_dias_treat_imp_sin_na +
                  lag_less_90d_tr1_rec+
                  lag_comp_bpsc_y3_severe_rec + 
                  lag_policonsumo2 + 
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidum_coc_rec2 +
                  susinidumrec_otr +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_with_rec2 +
                  psycom_dum_study + 
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar +
                  susprindumrec_otr +    
                  strat(tipo_de_plan_2_mod), 
                data=data_mine_miss_restr_proc2exp, 
                x=TRUE, y=TRUE, surv=TRUE, iter.max = 250*4, tol = 1e-6)

model_after_time_strat<-
cph(Surv(lag_time,time,event)~
          cluster(id)+ 
          lag_tr_outcome+
          lag_comp_bpsc_y3_severe+
          lag_less_90d_tr1+
          log_lag_dias_treat_imp_sin_na +
          lag_policonsumo2 + 
          edad_al_ing_1 + 
          ano_nac_corr + 
          susinidumrec_otr +
          susinidumrec_coc +
          susinidumrec_pbc +
          susinidumrec_mar +
          psycom_dum_study +
          psycom_dum_with +
          freq_cons_dum_5day +
          cond_oc_dum_2inact +
          cond_oc_dum_3unemp +
          susprindumrec_coc +
          susprindumrec_pbc +
          susprindumrec_mar +
          susprindumrec_otr +
          strat(tipo_de_plan_2_mod)+
          strat(time_interval3),
    data= data_mine_miss_restr_proc2exp %>% data.table::as.data.table() %>% data.frame(), 
    x=TRUE, y=TRUE, surv=TRUE, iter.max = 250*4, tol = 1e-6)

model_after_time_strat_alt<-
cph(Surv(lag_time,time,event)~
          cluster(id)+ 
          lag_tr_outcome+
          lag_comp_bpsc_y3_severe+
          lag_less_90d_tr1+
          log_lag_dias_treat_imp_sin_na +
          lag_policonsumo2 + 
          edad_al_ing_1 + 
          ano_nac_corr + 
          susinidumrec_otr +
          susinidumrec_coc +
          susinidumrec_pbc +
          susinidumrec_mar +
          psycom_dum_study +
          psycom_dum_with +
          freq_cons_dum_5day +
          cond_oc_dum_2inact +
          cond_oc_dum_3unemp +
          susprindumrec_otr +
          susprindumrec_coc +
          susprindumrec_pbc +
          susprindumrec_mar +
          strat(tipo_de_plan_2_mod)+
          strat(time_interval3_alt),
    data= data_mine_miss_restr_proc2exp %>% data.table::as.data.table() %>% data.frame(), 
    x=TRUE, y=TRUE, surv=TRUE, iter.max = 250*4, tol = 1e-6)

invisible("Problemático")
# broom::tidy(coxph(Surv(lag_time,time,event==1)~ 
#         cluster(id)+ 
#         lag_tr_outcome_rec +
#         log_lag_dias_treat_imp_sin_na +
#         lag_less_90d_tr1_rec+
#         lag_comp_bpsc_y3_severe_rec + 
#         lag_policonsumo2 + 
#         edad_al_ing_1 + 
#         ano_nac_corr + 
#         susinidum_coc_rec2 +
#         susinidumrec_otr +
#         susinidum_pbc +
#         susinidum_mar +
#         psycom_dum_with_rec2 +
#         psycom_dum_study + 
#         freq_cons_dum_5day +
#         cond_oc_dum_2inact +
#         cond_oc_dum_3unemp +
#         susprindum_oh +
#         susprindum_coc +
#         susprindum_pbc +
#         susprindum_mar+
#         strata(tipo_de_plan_2_mod), 
#     data=data_mine_miss_restr_proc2), exponentiate=T, conf.int=T)

models_hr_table2<-
rbind.data.frame(
cbind.data.frame(model="No correction", tidy.rms(cph_nocorr, conf.int=T, exponentiate=T)[, c("term","estimate", "conf.low", "conf.high")]%>% 
  dplyr::mutate_if(is.numeric, ~sprintf("%1.2f",.))),
cbind.data.frame(model="After PH", tidy.rms(cph_after_ph, conf.int=T, exponentiate=T)[, c("term","estimate", "conf.low", "conf.high")]%>% 
  dplyr::mutate_if(is.numeric, ~sprintf("%1.2f",.))),
cbind.data.frame(model="Stratifying", tidy.rms(model_after_time_strat, conf.int=T, exponentiate=T)[, c("term","estimate", "conf.low", "conf.high")]%>% 
  dplyr::mutate_if(is.numeric, ~sprintf("%1.2f",.))),
cbind.data.frame(model="Stratifying, alt strata", tidy.rms(model_after_time_strat_alt, conf.int=T, exponentiate=T)[, c("term","estimate", "conf.low", "conf.high")] %>% 
  dplyr::mutate_if(is.numeric, ~sprintf("%1.2f",.)))
)

models_hr_table2$term_label <- term_mapping$term_label[match(models_hr_table2$term, term_mapping$term)]

models_hr_table2%>%
  dplyr::select(term_label, everything()) %>% 
  {
    #copiar_nombres2(.)
    write.table(.,paste0(folder_path,"coxph_intensity_model_prev.csv"), dec=",", sep="\t")
    knitr::kable(.,size=10, format="html",caption= "Intensity model", escape=T)%>% 
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
     kableExtra::scroll_box(width = "100%", height = "375px")  
  }

```


### 0.c.Intensity model (with model that originated IWWs)

Taking other substances as dummy just as in `irrelong-21-iiw-weights-nocorr` (step 3).

```{r intensity-model-alcohol}
#| class-output: center-table
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true

term_mapping2 <- data.frame(
  term = c("lag_tr_outcome", "lag_comp_bpsc_y3_severe", "lag_less_90d_tr1", "log_lag_dias_treat_imp_sin_na", "lag_policonsumo2", "edad_al_ing_1", "ano_nac_corr", "susinidum_coc", "susinidum_pbc", "susinidum_mar", "susinidum_oh", "psycom_dum_study", "psycom_dum_with", "freq_cons_dum_5day", "cond_oc_dum_2inact", "cond_oc_dum_3unemp", "susprindum_coc", "susprindum_pbc", "susprindum_mar", "susprindum_oh",  "lag_tr_outcome_rec", "lag_less_90d_tr1_rec", "lag_comp_bpsc_y3_severe_rec", "susinidum_coc_rec2", "psycom_dum_with_rec2"),
  term_label = c("Treatment outcome of the previous treatment", "Previous biopsychosocial compromise (severe)", 
                 "Previous treatment duration (<90 days)", "Previous treatment duration (in logarithmic scaled days)", 
                 "Polysubstance use status of the previous treatment", "Age at admission to treatment", "Birth year", 
                  "Primary substance (initial diagnosis), cocaine", "Primary substance (initial diagnosis), cocaine base paste", "Primary substance (initial diagnosis), marijuana", "Primary substance (initial diagnosis), alcohol", "Psychiatric comorbidity (diagnosis unknown or under study)", "Psychiatric comorbidity (confirmed comorbidity)", "Daily frequence of primary substance use at admission", "Occupational status (inactive)", "Occupational status (unemployed)", "Primary substance at admission to treatment (cocaine hydrochloride)", "Primary substance at admission to treatment (cocaine base paste)", "Primary substance at admission to treatment (marijuana)", "Primary substance at admission to treatment (alcohol)", "Treatment outcome of the previous treatment (recoded for interaction with time)", "Previous biopsychosocial compromise (severe, recoded for interaction with time)", "Previous treatment duration (<90 days, recoded for interaction with time)", "Primary substance (initial diagnosis), cocaine (recoded for interaction with time)", "Psychiatric comorbidity (confirmed comorbidity, recoded for interaction with time)")
)

#susinidumrec_oh susprindumrec_oh

cph_nocorr_oh<-
  cph(Surv(lag_time,time,event)~
        cluster(id)+ 
        lag_tr_outcome+ #tr_outcome.lag
        lag_comp_bpsc_y3_severe+ #comp_bpsc_y3_severe.lag
        lag_less_90d_tr1+ #less_90d_tr1.lag
        log_lag_dias_treat_imp_sin_na + #log_dias_treat_imp_sin_na.lag
        lag_policonsumo2 +  #policonsumo2.lag 
        edad_al_ing_1 + 
        ano_nac_corr + 
        susinidum_oh+
        #susinidumrec_otr +
        susinidum_coc +
        susinidum_pbc +
        susinidum_mar +
        psycom_dum_study +
        psycom_dum_with +
        freq_cons_dum_5day +
        cond_oc_dum_2inact +
        cond_oc_dum_3unemp +
        susprindum_oh +
        susprindum_coc +
        susprindum_pbc +
        susprindum_mar +
        strat(tipo_de_plan_2_mod),
      data= data_mine_miss_restr_proc2 %>% data.table::as.data.table() %>% data.frame(), 
      x=TRUE, y=TRUE, surv=TRUE, iter.max = 250*4, tol = 1e-6)

models_hr_table2_oh<-
rbind.data.frame(
cbind.data.frame(model="No correction", tidy.rms(cph_nocorr_oh, conf.int=T, exponentiate=T)[, c("term","estimate", "conf.low", "conf.high")]%>% dplyr::mutate_if(is.numeric, ~sprintf("%1.2f",.)))
)

models_hr_table2_oh$term_label <- term_mapping2$term_label[match(models_hr_table2_oh$term, term_mapping2$term)]

models_hr_table2_oh%>%
  dplyr::select(term_label, everything()) %>% 
  {
    #copiar_nombres2(.)
    write.table(.,paste0(folder_path,"coxph_intensity_model_prev_250216.csv"), dec=",", sep="\t")
    knitr::kable(.,size=10, format="html",caption= "Intensity model (no correction, original)", escape=T)%>% 
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
     kableExtra::scroll_box(width = "100%", height = "375px")  
  }

```


## 0.d. Cox intensity model behind weights, under two scenarios (lag1 and lag0)

```{r intensity-model-2-scenarios}
#| class-output: center-table
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true

update_terms <- function(tidy_table, term_mapping2) {
  
  # Function to convert tidy_table term to mapping key.
  convert_term <- function(term) {
    # Check if the term ends with ".lag"
    if(grepl("\\.lag$", term)) {
      base <- sub("\\.lag$", "", term)
      # Special case: if the base is "log_dias_treat_imp_sin_na", insert "lag" after "log_"
      if(base == "log_dias_treat_imp_sin_na") {
        return("log_lag_dias_treat_imp_sin_na")
      } else {
        return(paste0("lag_", base))
      }
    } else {
      return(term)
    }
  }
  
  # Create a new column with the mapping key.
  tidy_table$term_key <- sapply(tidy_table$term, convert_term)
  
  # Merge the tidy_table with the term_mapping on the mapping key.
  # term_mapping has columns "term" and "term_label".
  tidy_table <- merge(tidy_table, term_mapping2, by.x = "term_key", by.y = "term", all.x = TRUE)
  
  # Replace the original term with the label if available.
  tidy_table$term <- ifelse(!is.na(tidy_table$term_label), tidy_table$term_label, tidy_table$term)
  
  # Remove temporary columns used for the merge.
  tidy_table$term_key <- NULL
  tidy_table$term_label <- NULL
  
  return(tidy_table)
}

tidy_table <- tidy_coxph(iiw_nocorr$m)

tidy_table_alt <- tidy_coxph(iiw_nocorr_alt$m)

term_vector <- c(
  "Treatment outcome of the previous treatment",
  "Previous treatment duration (in logarithmic scaled days)",
  "Previous treatment duration (<90 days)",
  "Previous biopsychosocial compromise (severe)",
  "Polysubstance use status of the previous treatment",
  "Age at admission to treatment",
  "Birth year",
  "Primary substance (initial diagnosis), cocaine",
  "Primary substance (initial diagnosis), alcohol",
  "Primary substance (initial diagnosis), cocaine base paste",
  "Primary substance (initial diagnosis), marijuana",
  "Psychiatric comorbidity (confirmed comorbidity)",
  "Psychiatric comorbidity (diagnosis unknown or under study)",
  "Daily frequence of primary substance use at admission",
  "Occupational status (inactive)",
  "Occupational status (unemployed)",
  "Primary substance at admission to treatment (alcohol)",
  "Primary substance at admission to treatment (cocaine hydrochloride)",
  "Primary substance at admission to treatment (cocaine base paste)",
  "Primary substance at admission to treatment (marijuana)"
)

rbind.data.frame(cbind.data.frame(lag="Lag 0", update_terms(format_hr_ci(tidy_table, digits = 2), term_mapping2)),cbind.data.frame(lag="Lag 1", update_terms(format_hr_ci(tidy_table_alt, digits = 2), term_mapping2)))%>% 
  dplyr::mutate(term= factor(term, levels=term_vector))%>% 
  dplyr::arrange(lag, term)%>% #rio::export("clipboard")
  {
    #copiar_nombres2(.)
    write.table(., paste0(folder_path,"coxph_intensity_model_250216.csv"), dec=",", sep="\t")
    knitr::kable(tidyr::pivot_wider(dplyr::select(.,"term","lag", "hr_ci"), names_from="lag", values_from="hr_ci"), size=10, format="html",caption= "Specifications of the treatment (visit) process, in Hazard Ratios (HR) and under different lagged variables scenarios (no correction, original)", escape=T)%>% 
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
     kableExtra::scroll_box(width = "100%", height = "375px")  
  }
```



# GEE


## 1. No correction

```{r}
#| class-output: center-table
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true
#| results: hold

plan_names <- attr(table(data_mine_miss_restr_proc2$tipo_de_plan_2_mod),"dimnames")[[1]]


model <- geese(tr_outcome ~ policonsumo2 +
                 comp_bpsc_y3_severe+
                 edad_al_ing_1 + 
                 ano_nac_corr + 
                 susinidumrec_otr +
                 susinidumrec_coc +
                 susinidumrec_pbc +
                 susinidumrec_mar +
                 psycom_dum_study +
                 psycom_dum_with +
                 freq_cons_dum_5day +
                 cond_oc_dum_2inact +
                 cond_oc_dum_3unemp +
                 susprindumrec_coc +
                 susprindumrec_pbc +
                 susprindumrec_mar +
                 susprindumrec_otr, #origen_ingreso_mod fis_comorbidity_icd_10 dg_trs_cons_sus_or
               id = id, 
               data = data_mine_miss_restr_proc2exp,
               family = poisson(), 
               corstr = "independence", 
               jack = T)

dplyr::filter(
  tidy_geese_model(model), Term=="policonsumo2")
#   Term         Estimate Std.Error z.value p.value CI.Lower CI.Upper
#   <chr>        <chr>    <chr>     <chr>   <chr>   <chr>    <chr>   
# 1 policonsumo2 1.02     0.01      2.53    0.0113  1.01     1.04 

model_weight <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar +
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = data_mine_miss_restr_proc2exp,
                weight = data_mine_miss_restr_proc2exp$iiw_nocorr_st,
                family = poisson("log"), 
                corstr = "independence")
dplyr::filter(summary2.geem(model_weight,exponentiate=T, digits=2), Term=="policonsumo2")
#           Term Estimates Model SE Robust SE Wald CI.lower CI.upper p.value
# 1 policonsumo2      1.03     0.01      0.01 2.70     1.01     1.05  0.0069

model_alt_weight <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar +
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = data_mine_miss_restr_proc2exp,
                weight = data_mine_miss_restr_proc2exp$iiw_nocorr_alt_st,
                family = poisson("log"), 
                corstr = "independence")

dplyr::filter(summary2.geem(model_alt_weight,exponentiate=T, digits=2), Term=="policonsumo2")
#           Term Estimates Model SE Robust SE Wald CI.lower CI.upper p.value
# 1 policonsumo2      1.02     0.01      0.01 1.95     1.00     1.04  0.0513
```

### 1.1. No correction, no weight 

Initialize a list to store models

```{r}
nocorr_nowgt_list <- list()
```

Loop over each unique plan name to fit a model

```{r gee11, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, #origen_ingreso_mod fis_comorbidity_icd_10 dg_trs_cons_sus_or
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  nocorr_nowgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```



#### 1.1.1 No correction, no weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_nocorr_nowgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee111, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar+
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = current_data,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_nocorr_nowgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```

#### 1.1.2 No correction, no weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(0.2, 16, by = 0.1)
```

Initialize a list to store models and their QICs

```{r}
geem2_nocorr_nowgt_list <- list()
```

Loop over each unique plan name to fit models



```{r gee112, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                    susprindumrec_coc +
                    susprindumrec_pbc +
                    susprindumrec_mar+
                    susprindumrec_otr, # Include relevant predictors
                  id = id, 
                  data = current_data,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_nocorr_nowgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


### 1.2. No correction, weight 

Initialize a list to store models

```{r}
nocorr_wgt_list <- list()
```

Loop over each unique plan name to fit a model



```{r gee12, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 weight = current_data$iiw_nocorr_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  nocorr_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


#### 1.2.1 No correction, weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_nocorr_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee121, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar +
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = current_data,
                weight = current_data$iiw_nocorr_st,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_nocorr_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```

#### 1.2.2 No correction, weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_nocorr_wgt_list <- list()
```

Loop over each unique plan name to fit models


```{r gee122, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                    susprindumrec_coc +
                    susprindumrec_pbc +
                    susprindumrec_mar +
                    susprindumrec_otr, # Include relevant predictors
                  id = id, 
                  data = current_data,
                  weight = current_data$iiw_nocorr_st,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_nocorr_wgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan


```{r}
#| class-output: center-table

print(geem2_nocorr_wgt_list[[1]])
```


### 1.3. No correction, alt. weight 

Initialize a list to store models

```{r}
nocorr_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee13, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 weight = current_data$iiw_nocorr_alt_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  nocorr_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```

#### 1.3.1 No correction, alt weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_nocorr_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee131, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar +
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = current_data,
                weight = current_data$iiw_nocorr_alt_st,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_nocorr_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


#### 1.3.2 No correction, alt weight, GEEM Negative binomial 


```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_nocorr_alt_wgt_list <- list()
```

Loop over each unique plan name to fit models


```{r gee132, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                    susprindumrec_coc +
                    susprindumrec_pbc +
                    susprindumrec_mar +
                    susprindumrec_otr, # Include relevant predictors
                  id = id, 
                  data = current_data,
                  weight = current_data$iiw_nocorr_alt_st,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_nocorr_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan

```{r}
#| class-output: center-table

print(geem2_nocorr_alt_wgt_list[[1]])
```


## 2. After PH

### 2.1. After PH, no weight 

Initialize a list to store models

```{r}
afterph_nowgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee21, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

data_mine_miss_restr_proc2exp_iiw_after_ph <-
  data_mine_miss_restr_proc2_iiw_after_ph %>% 
left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","n_off_acq","n_off_vio","n_off_sud","n_off_oth", "n_prev_off")], by="hash_key") %>% 
  {if (nrow(.) > nrow(data_mine_miss_restr_proc2_iiw_after_ph)) {message("left join added rows"); .} else .} %>% 
  dplyr::mutate(n_prev_off_bin= ifelse(n_prev_off>0,1,0)) %>% 
  dplyr::mutate(
    susinidumrec_coc = ifelse(sus_ini_mod_mvv == "Cocaine hydrochloride", 1, 0),
    susinidumrec_pbc = ifelse(sus_ini_mod_mvv == "Cocaine paste", 1, 0),
    susinidumrec_mar = ifelse(sus_ini_mod_mvv == "Marijuana", 1, 0),
    susinidumrec_otr = ifelse(sus_ini_mod_mvv == "Other", 1, 0), #sus_principal_mod
    susprindumrec_coc = ifelse(sus_principal_mod == "Cocaine hydrochloride", 1, 0),
    susprindumrec_pbc = ifelse(sus_principal_mod == "Cocaine paste", 1, 0),
    susprindumrec_mar = ifelse(sus_principal_mod == "Marijuana", 1, 0),
    susprindumrec_otr = ifelse(sus_principal_mod == "Other", 1, 0) # "susprindum_coc", "susprindum_pbc", "susprindum_mar", "susprindum_oh
  )

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 #weight= current_data$iiw_nocorr_alt_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  afterph_nowgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


##### 2.1.1 After PH, no weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_afterph_nowgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee211, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar +
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = current_data,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_afterph_nowgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


##### 2.1.2 After PH, no weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_afterph_nowgt_list <- list()
```

Loop over each unique plan name to fit models


```{r gee212, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                    susprindumrec_coc +
                    susprindumrec_pbc +
                    susprindumrec_mar +
                    susprindumrec_otr, # Include relevant predictors
                  id = id, 
                  data = current_data,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_afterph_nowgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan


```{r}
#| class-output: center-table

print(geem2_nocorr_nowgt_list[[1]])
```


As expected, QIC is equal, because the covariates and observations were the same

#### 2.2. After PH, weight 

Initialize a list to store models

```{r}
afterph_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee22, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 weight = current_data$iiw_after_ph_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  afterph_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


##### 2.2.1 After PH, weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_afterph_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee221, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindum_mar +
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = current_data,
                weight = current_data$iiw_after_ph_st,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_afterph_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


##### 2.2.2 After PH, weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_afterph_wgt_list <- list()
```

Loop over each unique plan name to fit models


```{r gee222, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                    susprindumrec_coc +
                    susprindumrec_pbc +
                    susprindumrec_mar +
                    susprindumrec_otr, # Include relevant predictors
                  id = id, 
                  data = current_data,
                  weight = current_data$iiw_after_ph_st,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_afterph_wgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan


```{r}
#| class-output: center-table

print(geem2_afterph_wgt_list[[1]])
```


#### 2.3. After PH, alt. weight 

Initialize a list to store models

```{r}
afterph_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee23, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

data_mine_miss_restr_proc2exp_iiw_after_ph_alt <-
  data_mine_miss_restr_proc2_iiw_after_ph_alt %>% 
left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","n_off_acq","n_off_vio","n_off_sud","n_off_oth", "n_prev_off")], by="hash_key") %>% 
  {if (nrow(.) > nrow(data_mine_miss_restr_proc2_iiw_after_ph_alt)) {message("left join added rows"); .} else .} %>% 
  dplyr::mutate(n_prev_off_bin= ifelse(n_prev_off>0,1,0)) %>% 
  dplyr::mutate(
    susinidumrec_coc = ifelse(sus_ini_mod_mvv == "Cocaine hydrochloride", 1, 0),
    susinidumrec_pbc = ifelse(sus_ini_mod_mvv == "Cocaine paste", 1, 0),
    susinidumrec_mar = ifelse(sus_ini_mod_mvv == "Marijuana", 1, 0),
    susinidumrec_otr = ifelse(sus_ini_mod_mvv == "Other", 1, 0), #sus_principal_mod
    susprindumrec_coc = ifelse(sus_principal_mod == "Cocaine hydrochloride", 1, 0),
    susprindumrec_pbc = ifelse(sus_principal_mod == "Cocaine paste", 1, 0),
    susprindumrec_mar = ifelse(sus_principal_mod == "Marijuana", 1, 0),
    susprindumrec_otr = ifelse(sus_principal_mod == "Other", 1, 0) # "susprindum_coc", "susprindum_pbc", "susprindum_mar", "susprindum_oh
  )


for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 weight = current_data$iiw_after_ph_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  afterph_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


##### 2.3.1 After PH, alt weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_afterph_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee231, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar +
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = current_data,
                weight = current_data$iiw_after_ph_st,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_afterph_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```

##### 2.3.2 After PH, alt weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_afterph_alt_wgt_list <- list()
```

Loop over each unique plan name to fit models

```{r gee232, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                    susprindumrec_coc +
                    susprindumrec_pbc +
                    susprindumrec_mar +
                    susprindumrec_otr, # Include relevant predictors
                  id = id, 
                  data = current_data,
                  weight = current_data$iiw_after_ph_st,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_afterph_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```

Check the result for a particular plan


```{r}
#| class-output: center-table

print(geem2_afterph_alt_wgt_list[[1]])
```


## 3. Stratifying

### 3.1. Stratifying, no weight 

Initialize a list to store models

```{r}
strata_nowgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee31, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table


data_mine_miss_proc2exp_iiw_strata <-
  data_mine_miss_proc2_iiw_strata %>% 
left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","n_off_acq","n_off_vio","n_off_sud","n_off_oth", "n_prev_off")], by="hash_key") %>% 
  {if (nrow(.) > nrow(data_mine_miss_restr_proc2_iiw_after_ph_alt)) {message("left join added rows"); .} else .} %>% 
  dplyr::mutate(n_prev_off_bin= ifelse(n_prev_off>0,1,0)) %>% 
  dplyr::mutate(
    susinidumrec_coc = ifelse(sus_ini_mod_mvv == "Cocaine hydrochloride", 1, 0),
    susinidumrec_pbc = ifelse(sus_ini_mod_mvv == "Cocaine paste", 1, 0),
    susinidumrec_mar = ifelse(sus_ini_mod_mvv == "Marijuana", 1, 0),
    susinidumrec_otr = ifelse(sus_ini_mod_mvv == "Other", 1, 0), #sus_principal_mod
    susprindumrec_coc = ifelse(sus_principal_mod == "Cocaine hydrochloride", 1, 0),
    susprindumrec_pbc = ifelse(sus_principal_mod == "Cocaine paste", 1, 0),
    susprindumrec_mar = ifelse(sus_principal_mod == "Marijuana", 1, 0),
    susprindumrec_otr = ifelse(sus_principal_mod == "Other", 1, 0) # "susprindum_coc", "susprindum_pbc", "susprindum_mar", "susprindum_oh
  )

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 #weight= current_data$iiw_nocorr_alt_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  strata_nowgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```

#### 3.1.1 Stratifying, no weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_strata_nowgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee311, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar +
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = current_data,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_strata_nowgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


#### 3.1.2 Stratifying, no weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_strata_nowgt_list <- list()
```

Loop over each unique plan name to fit models


```{r gee312, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                    susprindumrec_coc +
                    susprindumrec_pbc +
                    susprindumrec_mar +
                    susprindumrec_otr, # Include relevant predictors
                  id = id, 
                  data = current_data,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_strata_nowgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan


```{r}
#| class-output: center-table

print(geem2_nocorr_nowgt_list[[1]])
```


### 3.2. Stratifying, weight 

Initialize a list to store models

```{r}
strata_wgt_list <- list()
```

Loop over each unique plan name to fit a model

```{r gee32, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 weight = current_data$iiw_strata_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  strata_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


#### 3.2.1 Stratifying, weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_strata_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee321, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                id = id, 
                data = current_data,
                weight = current_data$iiw_strata_st,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_strata_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```

#### 3.2.2 Stratifying, weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_strata_wgt_list <- list()
```

Loop over each unique plan name to fit models


```{r gee322, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                  id = id, 
                  data = current_data,
                  weight= current_data$iiw_strata_st,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_strata_wgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan


```{r}
#| class-output: center-table

print(geem2_strata_wgt_list[[1]])
```


### 3.3. Stratifying, alt. weight 

Initialize a list to store models

```{r}
strata_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee33, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table


data_mine_miss_proc2exp_iiw_strata_alt <-
  data_mine_miss_proc2_iiw_strata_alt %>% 
left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","n_off_acq","n_off_vio","n_off_sud","n_off_oth", "n_prev_off")], by="hash_key") %>% 
  {if (nrow(.) > nrow(data_mine_miss_restr_proc2_iiw_after_ph_alt)) {message("left join added rows"); .} else .} %>% 
  dplyr::mutate(n_prev_off_bin= ifelse(n_prev_off>0,1,0)) %>% 
  dplyr::mutate(
    susinidumrec_coc = ifelse(sus_ini_mod_mvv == "Cocaine hydrochloride", 1, 0),
    susinidumrec_pbc = ifelse(sus_ini_mod_mvv == "Cocaine paste", 1, 0),
    susinidumrec_mar = ifelse(sus_ini_mod_mvv == "Marijuana", 1, 0),
    susinidumrec_otr = ifelse(sus_ini_mod_mvv == "Other", 1, 0), #sus_principal_mod
    susprindumrec_coc = ifelse(sus_principal_mod == "Cocaine hydrochloride", 1, 0),
    susprindumrec_pbc = ifelse(sus_principal_mod == "Cocaine paste", 1, 0),
    susprindumrec_mar = ifelse(sus_principal_mod == "Marijuana", 1, 0),
    susprindumrec_otr = ifelse(sus_principal_mod == "Other", 1, 0) # "susprindum_coc", "susprindum_pbc", "susprindum_mar", "susprindum_oh
  )


for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 weight = current_data$iiw_strata_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  strata_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


#### 3.3.1 Stratifying, alt weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_strata_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee331, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                id = id, 
                data = current_data,
                weight = current_data$iiw_strata_st,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_strata_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
#Alternative, better than main
```



```{r}
#| class-output: center-table

print(geem_strata_alt_wgt_list[[1]])
```


#### 3.3.2 No correction, alt weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_strata_alt_wgt_list <- list()
```

Loop over each unique plan name to fit models


```{r gee332, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                  id = id, 
                  data = current_data,
                  weight = current_data$iiw_strata_st,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_strata_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan


```{r}
#| class-output: center-table

print(geem2_strata_alt_wgt_list[[1]])
```


### 3.4. Stratifying, 2nd alt. weight 

Initialize a list to store models

```{r}
strata_alt_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee34, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table


data_mine_miss_proc2exp_iiw_strata_alt_alt <-
  data_mine_miss_proc2_iiw_strata_alt_alt %>% 
left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","n_off_acq","n_off_vio","n_off_sud","n_off_oth", "n_prev_off")], by="hash_key") %>% 
  {if (nrow(.) > nrow(data_mine_miss_restr_proc2_iiw_after_ph_alt)) {message("left join added rows"); .} else .} %>% 
  dplyr::mutate(n_prev_off_bin= ifelse(n_prev_off>0,1,0)) %>% 
  dplyr::mutate(
    susinidumrec_coc = ifelse(sus_ini_mod_mvv == "Cocaine hydrochloride", 1, 0),
    susinidumrec_pbc = ifelse(sus_ini_mod_mvv == "Cocaine paste", 1, 0),
    susinidumrec_mar = ifelse(sus_ini_mod_mvv == "Marijuana", 1, 0),
    susinidumrec_otr = ifelse(sus_ini_mod_mvv == "Other", 1, 0), #sus_principal_mod
    susprindumrec_coc = ifelse(sus_principal_mod == "Cocaine hydrochloride", 1, 0),
    susprindumrec_pbc = ifelse(sus_principal_mod == "Cocaine paste", 1, 0),
    susprindumrec_mar = ifelse(sus_principal_mod == "Marijuana", 1, 0),
    susprindumrec_otr = ifelse(sus_principal_mod == "Other", 1, 0) # "susprindum_coc", "susprindum_pbc", "susprindum_mar", "susprindum_oh
  )


for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata_alt_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 weight = current_data$iiw_strata_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  strata_alt_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


#### 3.4.1 Stratifying, alt weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_strata_alt_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model

```{r gee341, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata_alt_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                id = id, 
                data = current_data,
                weight = current_data$iiw_strata_st,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_strata_alt_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


```{r}
invisible("Alternative, worst model of strata")
```

#### 3.4.2 Stratifying, alt weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_strata_alt_alt_wgt_list <- list()
```

Loop over each unique plan name to fit models

```{r gee342, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata_alt_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                  id = id, 
                  data = current_data,
                  weight = current_data$iiw_strata_st,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_strata_alt_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan

```{r}
#| class-output: center-table

print(geem2_strata_alt_alt_wgt_list[[1]])
```


# Model output

```{r output-gee}
#| class-output: center-table
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true
#| results: hide

types_of_model<-
  c("No time-varying coefficients, no weight",
    "No time-varying coefficients, lag=0",
    "No time-varying coefficients, lag=1",
    "With time-varying coefficients, no weight",
    "With time-varying coefficients, lag=0",
    "With time-varying coefficients, lag=1",
    "Stratified by follow-up intervals, no weight",
    "Stratified by follow-up intervals, lag=0",
    "Stratified by follow-up intervals, lag=1",
    "Stratified by follow-up intervals, 2nd, lag=0"
)
types_of_model2<-
  c("No time-varying coefficients, no weight",
    "No time-varying coefficients, no weight, NB",
    "No time-varying coefficients, lag=0",
    "No time-varying coefficients, lag=0, NB",
    "No time-varying coefficients, lag=1",
    "No time-varying coefficients, lag=1, NB",
    "With time-varying coefficients, no weight",
    "With time-varying coefficients, no weight, NB",
    "With time-varying coefficients, lag=0",
    "With time-varying coefficients, lag=0, NB",
    "With time-varying coefficients, lag=1",
    "With time-varying coefficients, lag=1, NB",
    "Stratified by follow-up intervals, no weight",
    "Stratified by follow-up intervals, no weight, NB",
    "Stratified by follow-up intervals, lag=0",
    "Stratified by follow-up intervals, lag=0, NB",
    "Stratified by follow-up intervals, lag=1",
    "Stratified by follow-up intervals, lag=1, NB",
    "Stratified by follow-up intervals, 2nd, lag=1",
    "Stratified by follow-up intervals, 2nd, lag=1, NB"    
  )

plan_names[1]
cbind.data.frame(model= types_of_model,
rbind.data.frame(
dplyr::filter(tidy_geese_model(nocorr_nowgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(nocorr_wgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(nocorr_alt_wgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(afterph_nowgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(afterph_wgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(afterph_alt_wgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(strata_nowgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(strata_wgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(strata_alt_wgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(strata_alt_alt_wgt_list[[1]]), Term=="policonsumo2")))%>% 
  {
    copiar_nombres2(.)
    assign(paste0("result_data_geese_", gsub(" ","_",plan_names[1])), ., envir = .GlobalEnv)
    print(.)
  }

cbind.data.frame(model= types_of_model2,
     QIC= c(as.numeric(QIC(geem_nocorr_nowgt_list[[1]])),
            as.numeric(geem2_nocorr_nowgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_nocorr_wgt_list[[1]])),
            as.numeric(geem2_nocorr_wgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_nocorr_alt_wgt_list[[1]])),
            as.numeric(geem2_nocorr_alt_wgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_afterph_nowgt_list[[1]])),
            as.numeric(geem2_afterph_nowgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_afterph_wgt_list[[1]])),
            as.numeric(geem2_afterph_wgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_afterph_alt_wgt_list[[1]])),
            as.numeric(geem2_afterph_alt_wgt_list[[1]]$best_qic),
            
            as.numeric(QIC(geem_strata_nowgt_list[[1]])),
            as.numeric(geem2_strata_nowgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_strata_wgt_list[[1]])),
            as.numeric(geem2_strata_wgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_strata_alt_wgt_list[[1]])),
            as.numeric(geem2_strata_alt_wgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_strata_alt_alt_wgt_list[[1]])),
            as.numeric(geem2_strata_alt_alt_wgt_list[[1]]$best_qic)                        
            ),
     rbind.data.frame(
       dplyr::filter(summary2.geem(geem_nocorr_nowgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_nocorr_nowgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem_nocorr_wgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_nocorr_wgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem_nocorr_alt_wgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_nocorr_alt_wgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem_afterph_nowgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_afterph_nowgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem_afterph_wgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_afterph_wgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem_afterph_alt_wgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_afterph_alt_wgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       
       dplyr::filter(summary2.geem(geem_strata_nowgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_strata_nowgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),                   
       dplyr::filter(summary2.geem(geem_strata_wgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_strata_wgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem_strata_alt_wgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_strata_alt_wgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem_strata_alt_alt_wgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_strata_alt_alt_wgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2")
       ))%>% 
  {
    copiar_nombres2(.)
    assign(paste0("result_data_geem_", gsub(" ","_",plan_names[1])), ., envir = .GlobalEnv)
    print(.)
  }

i=2
plan_names[i]
cbind.data.frame(model= types_of_model,
rbind.data.frame(
  dplyr::filter(tidy_geese_model(nocorr_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_alt_wgt_list[[i]]), Term=="policonsumo2")))%>% 
  {
    copiar_nombres2(.)  
    print(.)
  }

#[1] "GP intensive ambulatory". significativo
cbind.data.frame(model= types_of_model2,
         QIC= c(as.numeric(QIC(geem_nocorr_nowgt_list[[i]])),
                as.numeric(geem2_nocorr_nowgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_nocorr_wgt_list[[i]])),
                as.numeric(geem2_nocorr_wgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_nocorr_alt_wgt_list[[i]])),
                as.numeric(geem2_nocorr_alt_wgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_afterph_nowgt_list[[i]])),
                as.numeric(geem2_afterph_nowgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_afterph_wgt_list[[i]])),
                as.numeric(geem2_afterph_wgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_afterph_alt_wgt_list[[i]])),
                as.numeric(geem2_afterph_alt_wgt_list[[i]]$best_qic),
                
                as.numeric(QIC(geem_strata_nowgt_list[[i]])),
                as.numeric(geem2_strata_nowgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_strata_wgt_list[[i]])),
                as.numeric(geem2_strata_wgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_strata_alt_wgt_list[[i]])),
                as.numeric(geem2_strata_alt_wgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_strata_alt_alt_wgt_list[[i]])),
                as.numeric(geem2_strata_alt_alt_wgt_list[[i]]$best_qic)                        
         ),
         rbind.data.frame(
           dplyr::filter(summary2.geem(geem_nocorr_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_nocorr_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem_nocorr_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_nocorr_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem_nocorr_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_nocorr_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem_afterph_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_afterph_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem_afterph_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_afterph_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem_afterph_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_afterph_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           
           dplyr::filter(summary2.geem(geem_strata_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_strata_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),                   
           dplyr::filter(summary2.geem(geem_strata_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_strata_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem_strata_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_strata_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem_strata_alt_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_strata_alt_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2")
         ))%>% 
  {
    copiar_nombres2(.)
    assign(paste0("result_data_geem_", gsub(" ","_",plan_names[i])), ., envir = .GlobalEnv)
    print(.)
  }


i=3
plan_names[i]
cbind.data.frame(model= types_of_model,
rbind.data.frame(
  dplyr::filter(tidy_geese_model(nocorr_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_alt_wgt_list[[i]]), Term=="policonsumo2"))) %>% 
  {
    copiar_nombres2(.)  
    print(.)
  }
cbind.data.frame(model= types_of_model2,
           QIC= c(as.numeric(QIC(geem_nocorr_nowgt_list[[i]])),
                  as.numeric(geem2_nocorr_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_nocorr_wgt_list[[i]])),
                  as.numeric(geem2_nocorr_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_nocorr_alt_wgt_list[[i]])),
                  as.numeric(geem2_nocorr_alt_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_nowgt_list[[i]])),
                  as.numeric(geem2_afterph_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_wgt_list[[i]])),
                  as.numeric(geem2_afterph_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_alt_wgt_list[[i]])),
                  as.numeric(geem2_afterph_alt_wgt_list[[i]]$best_qic),
                  
                  as.numeric(QIC(geem_strata_nowgt_list[[i]])),
                  as.numeric(geem2_strata_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_wgt_list[[i]])),
                  as.numeric(geem2_strata_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_alt_wgt_list[[i]])),
                  as.numeric(geem2_strata_alt_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_alt_alt_wgt_list[[i]])),
                  as.numeric(geem2_strata_alt_alt_wgt_list[[i]]$best_qic)                        
           ),
           rbind.data.frame(
             dplyr::filter(summary2.geem(geem_nocorr_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_nocorr_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_nocorr_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             
             dplyr::filter(summary2.geem(geem_strata_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),                   
             dplyr::filter(summary2.geem(geem_strata_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_strata_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_strata_alt_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_alt_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2")
           ))%>% 
  {
    copiar_nombres2(.)
    assign(paste0("result_data_geem_", gsub(" ","_",plan_names[i])), ., envir = .GlobalEnv)
    print(.)
  }


i=4
plan_names[i]
cbind.data.frame(model= types_of_model,
rbind.data.frame(
  dplyr::filter(tidy_geese_model(nocorr_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_alt_wgt_list[[i]]), Term=="policonsumo2"))) %>% 
  {
    copiar_nombres2(.)  
    print(.)
  }
cbind.data.frame(model= types_of_model2,
           QIC= c(as.numeric(QIC(geem_nocorr_nowgt_list[[i]])),
                  as.numeric(geem2_nocorr_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_nocorr_wgt_list[[i]])),
                  as.numeric(geem2_nocorr_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_nocorr_alt_wgt_list[[i]])),
                  as.numeric(geem2_nocorr_alt_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_nowgt_list[[i]])),
                  as.numeric(geem2_afterph_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_wgt_list[[i]])),
                  as.numeric(geem2_afterph_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_alt_wgt_list[[i]])),
                  as.numeric(geem2_afterph_alt_wgt_list[[i]]$best_qic),
                  
                  as.numeric(QIC(geem_strata_nowgt_list[[i]])),
                  as.numeric(geem2_strata_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_wgt_list[[i]])),
                  as.numeric(geem2_strata_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_alt_wgt_list[[i]])),
                  as.numeric(geem2_strata_alt_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_alt_alt_wgt_list[[i]])),
                  as.numeric(geem2_strata_alt_alt_wgt_list[[i]]$best_qic)                        
           ),
           rbind.data.frame(
             dplyr::filter(summary2.geem(geem_nocorr_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_nocorr_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_nocorr_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             
             dplyr::filter(summary2.geem(geem_strata_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),                   
             dplyr::filter(summary2.geem(geem_strata_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_strata_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_strata_alt_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_alt_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2")
           ))%>% 
  {
    copiar_nombres2(.)
    assign(paste0("result_data_geem_", gsub(" ","_",plan_names[i])), ., envir = .GlobalEnv)
    print(.)
  }

i=5
plan_names[i]
cbind.data.frame(model= types_of_model,
rbind.data.frame(
  dplyr::filter(tidy_geese_model(nocorr_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_alt_wgt_list[[i]]), Term=="policonsumo2"))) %>% 
  {
        copiar_nombres2(.)  
        print(.)
  }
  
cbind.data.frame(model= types_of_model2,
           QIC= c(as.numeric(QIC(geem_nocorr_nowgt_list[[i]])),
                  as.numeric(geem2_nocorr_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_nocorr_wgt_list[[i]])),
                  as.numeric(geem2_nocorr_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_nocorr_alt_wgt_list[[i]])),
                  as.numeric(geem2_nocorr_alt_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_nowgt_list[[i]])),
                  as.numeric(geem2_afterph_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_wgt_list[[i]])),
                  as.numeric(geem2_afterph_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_alt_wgt_list[[i]])),
                  as.numeric(geem2_afterph_alt_wgt_list[[i]]$best_qic),
                  
                  as.numeric(QIC(geem_strata_nowgt_list[[i]])),
                  as.numeric(geem2_strata_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_wgt_list[[i]])),
                  as.numeric(geem2_strata_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_alt_wgt_list[[i]])),
                  as.numeric(geem2_strata_alt_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_alt_alt_wgt_list[[i]])),
                  as.numeric(geem2_strata_alt_alt_wgt_list[[i]]$best_qic)                        
           ),
           rbind.data.frame(
             dplyr::filter(summary2.geem(geem_nocorr_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_nocorr_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_nocorr_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             
             dplyr::filter(summary2.geem(geem_strata_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),                   
             dplyr::filter(summary2.geem(geem_strata_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_strata_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_strata_alt_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_alt_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2")
           ))%>% 
  {
    copiar_nombres2(.)
    assign(paste0("result_data_geem_", gsub(" ","_",plan_names[i])), ., envir = .GlobalEnv)
    print(.)
  }
```


```{r output-gee-consolidated}
#| class-output: center-table
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true
rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                 cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                 cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
                 ) %>% 
  dplyr::group_by(setting) %>% 
  dplyr::mutate(min_qic_setting=ifelse(QIC==min(QIC),1,0)) %>% 
  dplyr::mutate(QIC= format(as.numeric(sprintf("%1.1f",QIC)), big.mark=",")) %>% 
  dplyr::ungroup() %>%
  dplyr::mutate(`RR (95% IC)`= paste0(Estimates, " (", `CI.lower`, ", ", CI.upper, ")")) %>% 
  dplyr::select(setting, model, QIC, `RR (95% IC)`, p.value) %>% 
  {
  #copiar_nombres2()
    write.table(., file = paste0(folder_path,"gee_240515.csv"), dec=",", sep="\t")
    knitr::kable(., size=10, format="html", caption="Relative risk of treatment non-completion status by reported polysubstance use") %>% 
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
    kableExtra::scroll_box(width = "100%", height = "375px")  
  }
```


# Stratifying by presence of alcohol among poly-substance use

```{r}

data_mine_miss_restr_proc2exp2<-
  data_mine_miss_restr_proc2 %>% 
  left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","n_off_acq","n_off_vio","n_off_sud","n_off_oth", "n_prev_off")], by="hash_key") %>%
  tidylog::left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","fech_ing_num","otras_sus1_mod","otras_sus2_mod","otras_sus3_mod")], by=c("hash_key"="hash_key","fech_ing_num"="fech_ing_num")) %>% 
  {if (nrow(.) > nrow(data_mine_miss_restr_proc2)) {message("left join added rows"); .} else .} %>% 
  dplyr::mutate(n_prev_off_bin= ifelse(n_prev_off>0,1,0)) %>% 
  dplyr::mutate(
    susinidumrec_coc = ifelse(sus_ini_mod_mvv == "Cocaine hydrochloride", 1, 0),
    susinidumrec_pbc = ifelse(sus_ini_mod_mvv == "Cocaine paste", 1, 0),
    susinidumrec_mar = ifelse(sus_ini_mod_mvv == "Marijuana", 1, 0),
    susinidumrec_otr = ifelse(sus_ini_mod_mvv == "Other", 1, 0), #sus_principal_mod
    susprindumrec_coc = ifelse(sus_principal_mod == "Cocaine hydrochloride", 1, 0),
    susprindumrec_pbc = ifelse(sus_principal_mod == "Cocaine paste", 1, 0),
    susprindumrec_mar = ifelse(sus_principal_mod == "Marijuana", 1, 0),
    susprindumrec_otr = ifelse(sus_principal_mod == "Other", 1, 0) # "susprindum_coc", "susprindum_pbc", "susprindum_mar", "susprindum_oh
  ) %>% 
  rowwise() %>%
  #Condition
  dplyr::mutate(oh_otras_sus = if_else("Alcohol" %in% c(otras_sus1_mod, otras_sus2_mod, otras_sus3_mod),1,0)) %>%
  dplyr::mutate(policonsumo2_rec= dplyr::case_when(policonsumo2==1 & oh_otras_sus==1~"2.both",policonsumo2==1 & oh_otras_sus==0~"1.only PSU",T~"0.no PSU")) %>% 
  ungroup()

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#

nocorr_nowgt_int_list<-list()
nocorr_nowgt_int_probs_list<-list()
nocor_nowgt_int_tab <-list()
for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp2, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geeglm(tr_outcome ~ policonsumo2_rec +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, #origen_ingreso_mod fis_comorbidity_icd_10 dg_trs_cons_sus_or
                 id = id, 
                 data = current_data,
                 family = poisson, 
                 corstr = "independence")

  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  
  nocor_nowgt_int_tab[[paste0("tab_", model_name)]] <- table(current_data$policonsumo2_rec, current_data$tr_outcome) %>% data.frame()
  nocorr_nowgt_int_list[[paste("model", model_name, sep = "_")]] <- model
  emmeans_response <- emmeans(model, ~policonsumo2_rec,  rg.limit=2e5, type = "response")
  nocorr_nowgt_int_probs_list[[paste0("emmeans_response_int_", model_name)]] <- emmeans_response
  assign(paste0("emmeans_response_int_", model_name), emmeans_response, envir = .GlobalEnv)
}

nocor_nowgt_int_tab[1]
nocor_nowgt_int_tab[2]
nocor_nowgt_int_tab[3]
nocor_nowgt_int_tab[4]
nocor_nowgt_int_tab[5]

# > nocor_nowgt_int_tab[1]
# $tab_basic_ambulatory
# Var1 Var2 Freq
# 1   0.no PSU    0  629
# 2 1.only PSU    0 1210
# 3     2.both    0  286
# 4   0.no PSU    1 1827
# 5 1.only PSU    1 4450
# 6     2.both    1 1591
# 
# > nocor_nowgt_int_tab[2]
# $tab_GP_intensive_ambulatory
# Var1 Var2 Freq
# 1   0.no PSU    0  624
# 2 1.only PSU    0 1615
# 3     2.both    0  401
# 4   0.no PSU    1 1573
# 5 1.only PSU    1 5226
# 6     2.both    1 2058
# 
# > nocor_nowgt_int_tab[3]
# $tab_GP_residential
# Var1 Var2 Freq
# 1   0.no PSU    0  261
# 2 1.only PSU    0  905
# 3     2.both    0  400
# 4   0.no PSU    1  572
# 5 1.only PSU    1 2360
# 6     2.both    1  706
# 
# > nocor_nowgt_int_tab[4]
# $tab_WO_intensive_ambulatory
# Var1 Var2 Freq
# 1   0.no PSU    0  110
# 2 1.only PSU    0  253
# 3     2.both    0   61
# 4   0.no PSU    1  292
# 5 1.only PSU    1  726
# 6     2.both    1  318
# 
# > nocor_nowgt_int_tab[5]
# $tab_WO_residential
# Var1 Var2 Freq
# 1   0.no PSU    0  172
# 2 1.only PSU    0  413
# 3     2.both    0  130
# 4   0.no PSU    1  289
# 5 1.only PSU    1 1147
# 6     2.both    1  383
# 
invisible("no hay tan pocos casos en un estrato, salvo en WO intensive ambulatory")



invisible("En el basic ambulatory, GP intensive-amb y GP residential, el sig es el ambos (consumo alcohol)")
  
#broom::tidy(nocorr_nowgt_int_list[[1]], exponentiate=T, conf.int=T)[1:3,] 
#    term                         estimate std.error statistic     p.value conf.low conf.high
#   <chr>                           <dbl>     <dbl>     <dbl>       <dbl>    <dbl>     <dbl>
# 1 (Intercept)                0.00000870    4.83       5.81  0.0159      6.68e-10     0.113
# 2 policonsumo2_rec1.only PSU 1.01          0.0143     0.488 0.485       9.82e- 1     1.04 
# 3 policonsumo2_rec2.both     1.08          0.0161    24.8   0.000000622 1.05e+ 0     1.12 

#broom::tidy(nocorr_nowgt_int_list[[2]], exponentiate=T, conf.int=T)[1:3,]
#   term                         estimate std.error statistic       p.value conf.low conf.high
#   <chr>                           <dbl>     <dbl>     <dbl>         <dbl>    <dbl>     <dbl>
# 1 (Intercept)                0.00000655    4.81        6.15 0.0132        5.23e-10    0.0822
# 2 policonsumo2_rec1.only PSU 1.02          0.0153      1.98 0.160         9.92e- 1    1.05  
# 3 policonsumo2_rec2.both     1.10          0.0162     35.1  0.00000000312 1.07e+ 0    1.14  

invisible("Aunque GP residential es protector el policonsumo en both")
#broom::tidy(nocorr_nowgt_int_list[[3]], exponentiate=T, conf.int=T)[1:3,]
#   term                       estimate std.error statistic  p.value     conf.low    conf.high
#   <chr>                         <dbl>     <dbl>     <dbl>    <dbl>        <dbl>        <dbl>
# 1 (Intercept)                   1.14     9.06    0.000199 0.989    0.0000000221 58484383.   
# 2 policonsumo2_rec1.only PSU    0.989    0.0275  0.175    0.676    0.937               1.04 
# 3 policonsumo2_rec2.both        0.885    0.0332 13.5      0.000243 0.830               0.945


invisible("En WO intensive ambulatory, no tira ninguno")

#broom::tidy(nocorr_nowgt_int_list[[4]], exponentiate=T, conf.int=T)[1:3,]
# # A tibble: 3 x 7
#   term                       estimate std.error statistic p.value conf.low  conf.high
#   <chr>                         <dbl>     <dbl>     <dbl>   <dbl>    <dbl>      <dbl>
# 1 (Intercept)                0.000318   12.0        0.452  0.501  2.02e-14 4991312.  
# 2 policonsumo2_rec1.only PSU 0.956       0.0357     1.62   0.203  8.91e- 1       1.02
# 3 policonsumo2_rec2.both     1.07        0.0376     3.13   0.0767 9.93e- 1       1.15
# 
invisible("En WO residential, ambos mueven la aguja a mayor riesgo")
# 
#broom::tidy(nocorr_nowgt_int_list[[5]], exponentiate=T, conf.int=T)[1:3,]
#   term                        estimate std.error statistic  p.value  conf.low conf.high
#   <chr>                          <dbl>     <dbl>     <dbl>    <dbl>     <dbl>     <dbl>
# 1 (Intercept)                249351.     11.6         1.15 0.284    0.0000331   1.88e15
# 2 policonsumo2_rec1.only PSU      1.14    0.0388     11.3  0.000775 1.06        1.23e 0
# 3 policonsumo2_rec2.both          1.14    0.0439      8.83 0.00297  1.05        1.24e 0
# 
# 
bind_rows(
    lapply(nocorr_nowgt_int_list[1:5], function(model) {
        broom::tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
            dplyr::select(term, estimate, conf.low, conf.high, p.value) %>%
        
            slice(2:3)
    }),
    .id = "model"
) %>% 
  dplyr::mutate(term= gsub("policonsumo2_","", term)) %>% 
  dplyr::mutate(across(c("estimate","conf.low", "conf.high"),~sprintf("%1.2f",.))) %>% 
  dplyr::mutate(RR= paste0(estimate, " (", conf.low,"-", conf.high,")")) %>% 
  dplyr::select(-estimate, -conf.low, -conf.high) %>% 
  dplyr::select(model, term, RR, p.value) %>% 
  dplyr::mutate(across(c("p.value"),~sprintf("%1.4f",.))) %>%
  {
  knitr::kable(., "markdown", caption= "Relative risk of treatment non-completion status by reported polysubstance use, whether ")
  }
```

```{r "fig-prev-psu-tr-noncomp", fig.align='center', paged.print=TRUE, fig.cap="Percentage distribution of treatment outcomes by treatment setting and polysubstance use status", results='hold', echo=T}
#| fig-width: 7
#| fig-height: 8.4
#| fig.showtext: true


# bind_rows(
#   lapply(1:5, function(model) {
#     nocor_nowgt_int_tab[[model]]%>% dplyr::mutate(Var0=ifelse(grepl("no PSU",Var1),1,0)) %>% dplyr::group_by(Var0, Var2) %>% dplyr::summarise(n= sum(Freq))
#   }),
#   .id = "model"
# ) %>% 
#   group_by(model) %>% 
#   summarise(n=sum(n))
data_barplot <- bind_rows(
  lapply(1:5, function(model) {
    nocor_nowgt_int_tab[[model]] %>% 
      dplyr::mutate(Var0 = ifelse(grepl("no PSU", Var1), "Single\nsubstance use", "Polysubstance\nuse")) %>% 
      dplyr::group_by(Var0, Var2) %>% 
      dplyr::summarise(n = sum(Freq))
  }),
  .id = "model"
) %>% 
  group_by(model, Var0) %>%
  mutate(percentage = n / sum(n)) %>%
  ungroup()

# Filter data for treatment non-completion only
data_non_completion <- data_barplot %>% filter(Var2 == "1")

# Create labels for the total counts and percentages for each group
labels <- data_barplot %>%
  group_by(model, Var0) %>%
  summarise(total = sum(n)) %>%
  mutate(label = scales::percent(total / sum(total), accuracy = 0.1))

# Calculate overall percentages for PSU and no PSU
overall_percentages <- data_barplot %>%
  group_by(model, Var0) %>%
  summarise(total = sum(n)) %>%
  mutate(overall_percentage = total / sum(total))

# Create a separate data frame for the labels
labels <- overall_percentages %>%
  mutate(label = scales::percent(overall_percentage, accuracy = 1))

data_barplot$Var0 <- factor(data_barplot$Var0, levels = c("Single\nsubstance use", "Polysubstance\nuse"))
labels$Var0 <- factor(labels$Var0, levels = c("Single\nsubstance use", "Polysubstance\nuse"))

showtext_auto()
showtext_opts(dpi = 500)
invisible("Si no funciona el times new roman")
#windowsFonts(TimesNewRoman = windowsFont("Times New Roman"))
# names(grDevices::windowsFonts())
# Generate the plot
ggplot(data_barplot, aes(x = factor(Var0), y = n, fill = factor(Var2))) +
  geom_bar(stat = "identity", position = position_stack(reverse = TRUE)) +
  #geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ model, ncol = 1, labeller = labeller(model = c(
    "1" = "Basic ambulatory (n= 9,993)",
    "2" = "General-population, intensive ambulatory (n= 11,497)",
    "3" = "General-population, residential (n= 5,204)",
    "4" = "Women-specific, intensive ambulatory (n= 1,760)",
    "5" = "Women-specific, residential (n= 2,534)"
  )), strip.position = "top") +
  scale_fill_manual(values = c("grey80", "grey35"), label=c("Completion", "Non-completion")) +
  labs(x = "Polysubstance use (PSU)", y = "Count", fill = "Treatment\noutcome") +
  geom_label(data = data_non_completion, aes(label = scales::percent(percentage, accuracy = 1)), position = position_stack(vjust = 0.8, reverse = TRUE), size = 3.9, fontface = "bold", color = "white", fill = "black", label.size = 0.2, family = "serif") +
   geom_text(data = labels, aes(x = Var0, y = 9e3, label = label, fill="1"), 
             size = 3.9, color = "black", hjust = 0.5, vjust = -0.5, fontface = "bold.italic", family = "serif") +
  ylim(0,1.1e4)+
  #theme_minimal(base_size = 14, base_family = "Times New Roman") +
  theme(
    strip.text = element_text(size = 12, face = "bold", family = "serif"),
    #axis.text.x = element_text(angle = 0, hjust = 1),
    axis.title.x = element_blank(),
    axis.text = element_text(size = 12, family = "serif"),
    axis.text.x = element_text(family = "serif"),
    text = element_text(family = "serif"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    strip.text.x = element_text(angle = 0, hjust = 0.5, size = 12, face = "bold", family = "serif"),
    strip.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "bottom",
    legend.text = element_text(size= 12, family = "serif"),
    legend.title = element_text(size= 13, family = "serif"),
  )
ggsave("E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/_figs/barplot3.png", height=14*.68, width=10*.68, dpi=500)
ggsave("E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/_figs/barplot3.jpg", height=14*.68, width=10*.68, dpi=500)
```


```{r "contrasts-comp-tr-setting", fig.align='center', paged.print=TRUE}
#data_barplot
#
mantelhaen.test(
xtabs(n ~Var2+ Var0 +model, data= data_barplot)
)
#Mantel-Haenszel X-squared = 93.675, df = 1, p-value < 2.2e-16

invisible("Si bien se ve una aso")

chisq.test(xtabs(n ~Var2+ Var0, data= data_barplot))
#X-squared = 76.039, df = 1, p-value < 2.2e-16

vcd::woolf_test(
  xtabs(n ~Var2+ Var0 +model, data= data_barplot)
)
#Woolf-test on Homogeneity of Odds Ratios (no 3-Way assoc.)
#X-squared = 13.735, df = 4, p-value = 0.008192

invisible("Los odds de no completar varían por baseline tr. setting (p<0,001)")
invisible("No se puede usar Maentel-haenzel")
invisible("Suggests conditional dependence and varying strength or direction of association across strata (interaction), cautioning against a simple summary of the association.[common OR may not be reliable]")


# nocor_nowgt_int_tab[[1]] %>% 
#       dplyr::mutate(Var0 = ifelse(grepl("no PSU", Var1), "Single\nsubstance use", "Polysubstance\nuse")) %>% 
#       dplyr::group_by(Var0, Var2) %>% 
#       dplyr::summarise(n = sum(Freq))
chisq.test(
xtabs(n ~ Var2+Var0, data = nocor_nowgt_int_tab[[1]] %>% 
          dplyr::mutate(Var0 = ifelse(grepl("no PSU", Var1), "Single\nsubstance use", "Polysubstance\nuse")) %>% 
          dplyr::group_by(Var0, Var2) %>% 
          dplyr::summarise(n = sum(Freq)))
)
#X-squared = 36.389, df = 1, p-value = 1.616e-09
# Phi-Coefficient   : 0.061 
# Contingency Coeff.: 0.061 
# Cramer's V        : 0.061 


chisq.test(
xtabs(n ~ Var2+Var0, data = nocor_nowgt_int_tab[[2]] %>% 
          dplyr::mutate(Var0 = ifelse(grepl("no PSU", Var1), "Single\nsubstance use", "Polysubstance\nuse")) %>% 
          dplyr::group_by(Var0, Var2) %>% 
          dplyr::summarise(n = sum(Freq)))
)
#X-squared = 45.055, df = 1, p-value = 1.916e-11
# Phi-Coefficient   : 0.063 
# Contingency Coeff.: 0.063 
# Cramer's V        : 0.063

chisq.test(
xtabs(n ~ Var2+Var0, data = nocor_nowgt_int_tab[[3]] %>% 
          dplyr::mutate(Var0 = ifelse(grepl("no PSU", Var1), "Single\nsubstance use", "Polysubstance\nuse")) %>% 
          dplyr::group_by(Var0, Var2) %>% 
          dplyr::summarise(n = sum(Freq)))
)
#X-squared = 0.65673, df = 1, p-value = 0.4177
# hi-Coefficient   : 0.012 
# Contingency Coeff.: 0.012 
# Cramer's V        : 0.012 
# 
chisq.test(
xtabs(n ~ Var2+Var0, data = nocor_nowgt_int_tab[[4]] %>% 
          dplyr::mutate(Var0 = ifelse(grepl("no PSU", Var1), "Single\nsubstance use", "Polysubstance\nuse")) %>% 
          dplyr::group_by(Var0, Var2) %>% 
          dplyr::summarise(n = sum(Freq)))
)
#X-squared = 2.8231, df = 1, p-value = 0.09291
# Phi-Coefficient   : 0.042 
# Contingency Coeff.: 0.042 
# Cramer's V        : 0.042 
#
invisible("setting 5= No completar vs. completar, según PSU vs. no-PSU")
chisq.test(
xtabs(n ~ Var2+Var0, data = nocor_nowgt_int_tab[[5]] %>% 
          dplyr::mutate(Var0 = ifelse(grepl("no PSU", Var1), "Single\nsubstance use", "Polysubstance\nuse")) %>% 
          dplyr::group_by(Var0, Var2) %>% 
          dplyr::summarise(n = sum(Freq)))
)
#X-squared = 22.463, df = 1, p-value = 2.142e-06
# Phi-Coefficient   : 0.095 
# Contingency Coeff.: 0.095 
# Cramer's V        : 0.095 
invisible("compare setting vs. PSUs")
chisq.test(xtabs(n ~Var0+ model, data= data_barplot))
#X-squared = 194.31, df = 4, p-value < 2.2e-16


# Cox, M. K., & Key, C. H. (1993). Post hoc pair-wise comparisons for the chi-square test of homogeneity of proportions. Educational and Psychological Measurement, 53(4), 951–962. https://doi.org/10.1177/0013164493053004008

invisible("Settings vs. noncompletion")

chisq.test(xtabs(n ~Var2+ model, data= data_barplot))
#X-squared = 177.64, df = 4, p-value < 2.2e-16

cat("For each baseline setting, calculate the std. residuals of chi-square, to compare non-completion shares")
data.frame(chisq.posthoc.test(xtabs(n ~Var2+ model, data= data_barplot))) |> 
    dplyr::mutate(X4=as.character(X4)) |> 
    pivot_longer(cols = c(`X1`,`X2`,`X3`,`X4`,`X5`), names_to = "Group", values_to = "Values") %>%
    pivot_wider(names_from = Value, values_from = Values) %>%
    dplyr::filter(Dimension=="1") %>%
  dplyr::mutate(across(1, ~ gsub("\n"," ",as.character(.))))|>
    dplyr::mutate(Residuals= sprintf("%1.2f", as.numeric(Residuals))) %>% 
    dplyr::mutate( `p values`= sprintf("%1.3f", as.numeric(gsub("\\*","",`p values`)))) %>%
    dplyr::select(Dimension, Residuals, `p values`) %>% 
  dplyr::mutate(`p values`= ifelse(`p values`=="0.000","<0.001",`p values`))


data.frame(chisq.posthoc.test(xtabs(n ~Var0+ model, data= data_barplot))) |> 
    dplyr::mutate(X4=as.character(X4)) |> 
    pivot_longer(cols = c(`X1`,`X2`,`X3`,`X4`,`X5`), names_to = "Group", values_to = "Values") %>%
    pivot_wider(names_from = Value, values_from = Values) %>%
    dplyr::filter(Dimension=="Polysubstance\nuse") %>%
  dplyr::mutate(across(1, ~ gsub("\n"," ",as.character(.))))|>
    dplyr::mutate(Residuals= sprintf("%1.2f", as.numeric(Residuals))) %>% 
    dplyr::mutate( `p values`= sprintf("%1.3f", as.numeric(gsub("\\*","",`p values`)))) %>%
    dplyr::select(Dimension, Residuals, `p values`) %>% 
  dplyr::mutate(`p values`= ifelse(`p values`=="0.000","<0.001",`p values`))

```


```{r "contrasts-rrs-nocorr-nowgt", fig.align='center', paged.print=TRUE}
#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#
nocorr_nowgt_int2_list<-
bind_rows(
  lapply(nocorr_nowgt_int_list[1:5], function(model) {
    broom::tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
      dplyr::select(term, estimate, std.error, conf.low, conf.high, p.value) %>%
      dplyr::mutate(log_rr= log(estimate), log_lcl= log(conf.low), log_ucl= log(conf.high), variance= ((log_ucl-log_rr)/qnorm(0.975))^2)%>% 
      dplyr::slice(2:3)
  }),
  .id = "model"
)

log_rr_int<- nocorr_nowgt_int2_list$log_rr  
variances_int<- nocorr_nowgt_int2_list$variance  


results_int <- expand.grid(i=1:5, j=1:5) %>%
  filter(i < j) %>%
  mutate(
    drrr = log_rr_int[i] - log_rr_int[j],
    var_drrr = variances_int[i] + variances_int[j],
    se_drrr = sqrt(var_drrr),
    z_value = drrr / se_drrr,
    p_value = 2 * (1 - pnorm(abs(z_value))),
    ratio_estimates = exp(drrr),
    lower_bound = exp(drrr - qnorm(0.975) * se_drrr),
    upper_bound = exp(drrr + qnorm(0.975) * se_drrr)
  ) %>% 
  dplyr::mutate(i= dplyr::case_when(i==1~plan_names[1], i==2~plan_names[2], 
                i==3~plan_names[3], i==4~plan_names[4], i==5~plan_names[5]), 
                j= dplyr::case_when(j==1~plan_names[1], j==2~plan_names[2], 
                j==3~plan_names[3], j==4~plan_names[4], j==5~plan_names[5]))
```


# Marginal probabilities

Loop over each unique plan name to fit a model. We used an interaction of PSU and treatment setting to capture the heterogeneity of PSU by treatment setting.

```{r output-marginal-emmeans}
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true


df_marginal_plots<-
  cbind.data.frame(wgt= c("wgt", "iiw_nocorr_st", "iiw_nocorr_alt_st", "wgt", "iiw_after_ph_st", "iiw_after_ph_st"), 
        df= c("data_mine_miss_restr_proc2exp","data_mine_miss_restr_proc2exp","data_mine_miss_restr_proc2exp","data_mine_miss_restr_proc2exp_iiw_after_ph","data_mine_miss_restr_proc2exp_iiw_after_ph","data_mine_miss_restr_proc2exp_iiw_after_ph_alt"),
        model= c("no corr no wgt","no corr main","no corr alt", "after ph no wgt", "after ph main", "after ph alt"))

# Loop over each unique plan name to fit a model
for (i in seq_along(df_marginal_plots$wgt)) {
  # Subset the data for the current plan type
  #current_data <- subset(data_mine_miss_restr_proc2, tipo_de_plan_2_mod == plan_names[i])
  geeglm( tr_outcome  ~ policonsumo2 * tipo_de_plan_2_mod +
                        edad_al_ing_1 + 
                        ano_nac_corr + 
                        susinidumrec_otr +
                        susinidumrec_coc +
                        susinidumrec_pbc +
                        susinidumrec_mar +
                        psycom_dum_study +
                        psycom_dum_with +
                        freq_cons_dum_5day +
                        cond_oc_dum_2inact +
                        cond_oc_dum_3unemp +
                       susprindumrec_coc +
                       susprindumrec_pbc +
                       susprindumrec_mar +
                       susprindumrec_otr, 
                    id= id, 
                    data= get(df_marginal_plots$df[i]) %>% dplyr::mutate(wgt=1), 
                    weight= get(df_marginal_plots$df[i]) %>% dplyr::mutate(wgt=1) %>% pull(df_marginal_plots$wgt[i]), 
                    family= poisson, 
                    corstr= "independence") %>% 
  assign(paste0("geeglm_", gsub(" ","_",df_marginal_plots$model[i])), ., envir = .GlobalEnv)
  print(message(paste0("Models: ",paste0("geeglm_", gsub(" ","_",df_marginal_plots$model[i])))))
  emmeans_response <- emmeans(get(paste0("geeglm_", gsub(" ","_",df_marginal_plots$model[i]))), ~policonsumo2+tipo_de_plan_2_mod,  rg.limit=2e5, type = "response")%>% assign(paste0("emmeans_response_", gsub(" ","_",df_marginal_plots$model[i])), ., envir = .GlobalEnv)
  print(message(paste0("Emmeans: ",paste0("emmeans_response_", gsub(" ","_",df_marginal_plots$model[i])))))
}
```


```{r output-marginal-emmeans-plot, fig.align="center", dpi=300}
#| class-output: center-table
#| message: false
#| include: true
#| warning: true
#| error: false
#| eval: true
#| fig.showtext: true

plot(emmeans_response_no_corr_no_wgt)+ ggtitle("No corr, no weights")#+ geom_point(aes(x = percent, y = conc), data = pigs, pch = 2, color = "blue")
plot(emmeans_response_no_corr_main)+ ggtitle("No corr, main weights")
plot(emmeans_response_no_corr_alt)+ ggtitle("No corr, alt weights")
plot(emmeans_response_after_ph_no_wgt)+ ggtitle("After PH, no weights")
plot(emmeans_response_after_ph_main)+ ggtitle("After PH, main weights")
plot(emmeans_response_after_ph_alt)+ ggtitle("After PH, alt weights")
```

# Heterogeneity

```{r heterogeneity}
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true

library(meta)
try(library(dmetar))
library(metafor)


#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
##_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
##
# Define los valores de los Relative Risk Reductions (RRR) y sus intervalos de confianza
rrr <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                 cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                 cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, no weight") %>% pull(`Estimates`) %>% as.numeric()
lcl <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                 cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                 cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, no weight") %>% pull(`CI.lower`) %>% as.numeric()
ucl <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                 cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                 cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, no weight") %>% pull(`CI.upper`) %>% as.numeric()


# Calcula los logaritmos de los RRR y de los límites de sus intervalos de confianza
log_rrr <- log(rrr)
log_lcl <- log(lcl)
log_ucl <- log(ucl)

# Calcula las varianzas
variances <- ((log_ucl - log_rrr) / qnorm(0.975))^2

# Meta-análisis usando un modelo de efectos aleatorios
meta_analysis <- rma(yi=log_rrr, sei=sqrt(variances), method="REML")

# Prueba de Cochran Q para evaluar la heterogeneidad
cochrans_q <- meta_analysis$QE
p_value_q <- meta_analysis$QEp

cat(sprintf("No time-varying coefficients, no weight- Cochran's Q = %.2f, p-value = %.4f\n", cochrans_q, p_value_q))
#concuerda con el calculo de stata
#
#

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
##_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
###_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
###
###

# Define los valores de los Relative Risk Reductions (RRR) y sus intervalos de confianza
rrr2 <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                         cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                         cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                         cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                         cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, lag=0") %>% pull(`Estimates`) %>% as.numeric()
lcl2 <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                         cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                         cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                         cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                         cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, lag=0") %>% pull(`CI.lower`) %>% as.numeric()
ucl2 <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                         cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                         cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                         cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                         cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, lag=0") %>% pull(`CI.upper`) %>% as.numeric()


# Calcula los logaritmos de los RRR y de los límites de sus intervalos de confianza
log_rrr2 <- log(rrr2)
log_lcl2 <- log(lcl2)
log_ucl2 <- log(ucl2)

# Calcula las varianzas
variances2 <- ((log_ucl2 - log_rrr2) / qnorm(0.975))^2

# Meta-análisis usando un modelo de efectos aleatorios
meta_analysis2 <- rma(yi=log_rrr2, sei=sqrt(variances2), method="REML")

# Prueba de Cochran Q para evaluar la heterogeneidad
cochrans_q2 <- meta_analysis2$QE
p_value_q2 <- meta_analysis2$QEp

cat(sprintf("No time-varying coefficients, lag=0, main- Cochran's Q = %.2f, p-value = %.4f\n", cochrans_q2, p_value_q2))
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
##_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
###_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

# Define los valores de los Relative Risk Reductions (RRR) y sus intervalos de confianza
rrr3 <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                 cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                 cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, lag=1") %>% pull(`Estimates`) %>% as.numeric()
lcl3 <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                 cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                 cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, lag=1") %>% pull(`CI.lower`) %>% as.numeric()
ucl3 <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                 cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                 cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, lag=1") %>% pull(`CI.upper`) %>% as.numeric()


# Calcula los logaritmos de los RRR y de los límites de sus intervalos de confianza
log_rrr3 <- log(rrr3)
log_lcl3 <- log(lcl3)
log_ucl3 <- log(ucl3)

# Calcula las varianzas
variances3 <- ((log_ucl3 - log_rrr3) / qnorm(0.975))^2

# Meta-análisis usando un modelo de efectos aleatorios
meta_analysis3 <- rma(yi=log_rrr3, sei=sqrt(variances3), method="REML")

# Prueba de Cochran Q para evaluar la heterogeneidad
cochrans_q3 <- meta_analysis3$QE
p_value_q3 <- meta_analysis3$QEp

cat(sprintf("No time-varying coefficients, lag=1- Cochran's Q = %.2f, p-value = %.4f\n", cochrans_q3, p_value_q3))

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
##_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
###_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
###

# Comparaciones de Altman para todas las combinaciones de RRR
results <- expand.grid(i=1:5, j=1:5) %>%
  filter(i < j) %>%
  mutate(
    drrr = log_rrr[i] - log_rrr[j],
    var_drrr = variances[i] + variances[j],
    se_drrr = sqrt(var_drrr),
    z_value = drrr / se_drrr,
    p_value = 2 * (1 - pnorm(abs(z_value))),
    ratio_estimates = exp(drrr),
    lower_bound = exp(drrr - qnorm(0.975) * se_drrr),
    upper_bound = exp(drrr + qnorm(0.975) * se_drrr)
  ) %>% 
  dplyr::mutate(i= dplyr::case_when(i==1~plan_names[1], i==2~plan_names[2], i==3~plan_names[3], i==4~plan_names[4], i==5~plan_names[5]), j= dplyr::case_when(j==1~plan_names[1], j==2~plan_names[2], j==3~plan_names[3], j==4~plan_names[4], j==5~plan_names[5]))

results2 <- expand.grid(i=1:5, j=1:5) %>%
  filter(i < j) %>%
  mutate(
    drrr = log_rrr2[i] - log_rrr2[j],
    var_drrr = variances2[i] + variances2[j],
    se_drrr = sqrt(var_drrr),
    z_value = drrr / se_drrr,
    p_value = 2 * (1 - pnorm(abs(z_value))),
    ratio_estimates = exp(drrr),
    lower_bound = exp(drrr - qnorm(0.975) * se_drrr),
    upper_bound = exp(drrr + qnorm(0.975) * se_drrr)
  ) %>% 
  dplyr::mutate(i= dplyr::case_when(i==1~plan_names[1], i==2~plan_names[2], i==3~plan_names[3], i==4~plan_names[4], i==5~plan_names[5]), j= dplyr::case_when(j==1~plan_names[1], j==2~plan_names[2], j==3~plan_names[3], j==4~plan_names[4], j==5~plan_names[5]))

results3 <- expand.grid(i=1:5, j=1:5) %>%
  filter(i < j) %>%
  mutate(
    drrr = log_rrr3[i] - log_rrr3[j],
    var_drrr = variances3[i] + variances3[j],
    se_drrr = sqrt(var_drrr),
    z_value = drrr / se_drrr,
    p_value = 2 * (1 - pnorm(abs(z_value))),
    ratio_estimates = exp(drrr),
    lower_bound = exp(drrr - qnorm(0.975) * se_drrr),
    upper_bound = exp(drrr + qnorm(0.975) * se_drrr)
  ) %>% 
  dplyr::mutate(i= dplyr::case_when(i==1~plan_names[1], i==2~plan_names[2], i==3~plan_names[3], i==4~plan_names[4], i==5~plan_names[5]), j= dplyr::case_when(j==1~plan_names[1], j==2~plan_names[2], j==3~plan_names[3], j==4~plan_names[4], j==5~plan_names[5]))

# Imprime los resultados
#el 5 tiene el mayor efecto en omparación con el resto
#
bind_rows(cbind.data.frame(model= "No time-varying coefficients, no weight",results), 
                 cbind.data.frame(model= "No time-varying coefficients, lag=0",results2), 
                 cbind.data.frame(model= "No time-varying coefficients, lag=1",results3)
                 ) %>% 
  dplyr::mutate(across(c("drrr","var_drrr", "se_drrr", "z_value", "ratio_estimates", "lower_bound", "upper_bound"),~sprintf("%1.2f",.))) %>% 
  dplyr::mutate(across(c("p_value"),~sprintf("%1.4f",.))) %>% 
  dplyr::mutate(`rrr (95% IC)`= paste0(ratio_estimates, " (", lower_bound, ", ", upper_bound,")")) %>% 
  dplyr::select(-any_of(c("drrr", "var_drrr", "se_drrr", "z_value", "ratio_estimates", "lower_bound", "upper_bound"))) %>% 
  {
  #copiar_nombres2()
    write.table(., file = paste0(folder_path,"rr_contrasts_240625.csv"), dec=",", sep="\t")
    knitr::kable(., size=10, format="html", caption="GEE Models, Heterogeneity & contrasts by setting") %>% 
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
     kableExtra::scroll_box(width = "100%", height = "375px")  
  }
```



# Session info

```{r session-info, echo=T, error=T, message=TRUE, paged.print=TRUE,eval=T}
message(paste0("R library: ", Sys.getenv("R_LIBS_USER")))
message(paste0("Date: ",withr::with_locale(new = c('LC_TIME' = 'C'), code =Sys.time())))
message(paste0("Editor context: ", path))
```


```{r session-info-r, echo=T, error=T, message=TRUE, paged.print=TRUE,eval=T}
#| class-output: center-table

sesion_info <- devtools::session_info()
dplyr::select(
  tibble::as_tibble(sesion_info$packages),
  c(package, loadedversion, source)
) %>% 
 knitr::kable(caption = "R packages", format = "html",
      col.names = c("Row number", "Package", "Version"),
    row.names = FALSE,
      align = c("c", "l", "r")) %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
  kableExtra::scroll_box(width = "100%", height = "375px")  
```


```{r session-info-python, echo=T, error=T, message=TRUE, paged.print=TRUE,eval=T}
#| class-output: center-table

reticulate::py_list_packages()%>% 
 knitr::kable(caption = "Python packages", format = "html",
      col.names = c("Package", "Version", "Requirement"),
    row.names = FALSE,
      align = c("c", "l", "r", "r"))%>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
  kableExtra::scroll_box(width = "100%", height = "375px")  
```


# Output 

```{r}
invisible("Adicionales en E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/para_pres_cum_mean.R")
folder_path <- ifelse(dir.exists("E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/"),
                      "E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/",
                      "G:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/")
save.image(paste0(folder_path,"an_grant_23_24_4.RData"))
invisible("ültima vs. estable")
#load(paste0(folder_path,"1_an_grant_23_24_4.RData"))
```