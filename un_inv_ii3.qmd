---
title: "Polysubstance and tr. completion"
description: |
  Analyze the association between polysubstance at admission and tr. compleiton longitudinally along treatments, accounting for irregular observations.
date: "`r format(Sys.time(),'%B %d, %Y')`"
author: "Andrés González Santa Cruz"
format: 
  html:
    css: styles.scss
    code-fold: true
    embed-resources: true
    # include-in-header:
    #   - custom-styles.css
    #   - custom-scripts.js
---

```{css}
#| echo: false

body {
  font-family: 'Times New Roman', Times, serif;
}

```
# Setup

```{r}
#| message: false
#| include: true
#| warning: false

rm(list = ls()) 
folder_path <- ifelse(dir.exists("E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/"),
                      "E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/",
                      "C:/Users/CISS Fondecyt/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/")
load(paste0(folder_path,"an_grant_23_24_3.RData"))
```



# Packages

```{r}
#| class-output: center-table
#| message: false
#| include: true
#| warning: false

system("fc-cache -f -v")

pacman::p_unlock(lib.loc = .libPaths()) #para no tener problemas reinstalando paquetes


if (getRversion() != "4.1.2") { stop("Requires R version 4.1.2. Actual: ", getRversion()) }


if(!require(geepack)){install.packages("geepack");library(geepack)}
if(!require(geeM)){install.packages("geeM");library(geeM)}
if(!require(tidyverse)){install.packages("tidyverse");library(tidyverse)}
if(!require(MASS)){install.packages("MASS");library(MASS)}
if(!require(geeasy)){install.packages("geeasy");library(geeasy)}
if(!require(MuMIn)){remotes::install_version("MuMIn", "1.46.0");library(MuMIn)}
if(!require(tableone)){install.packages("tableone");library(tableone)}
if(!require(knitr)){install.packages("knitr");library(knitr)}
if(!require(emmeans)){install.packages("emmeans");library(emmeans)}
if(!require(biostat3)){install.packages("biostat3");library(biostat3)}
if(!require(rms)){install.packages("rms");library(rms)}
if(!require(meta)){install.packages("meta");library(meta)}
try(if(!require(dmetar)){install.packages("dmetar");library(dmetar)})
if(!require(metafor)){install.packages("metafor");library(metafor)}
try(if(!require(extrafont)){install.packages("extrafont");library(extrafont)})
try(if(!require(showtext)){install.packages("showtext");library(showtext)})

try(extrafont::font_import(pattern = "Times New Roman", prompt = FALSE))
extrafont::loadfonts(device="win")
# Agregar la ruta a la fuente "Times New Roman"
font_add("Times New Roman", "C:/Windows/Fonts/times.ttf")

# Habilitar showtext para gráficos
showtext::showtext_auto()

#https://gist.github.com/avallecam/56af06f46e5544c3af0f46344df20989 
#https://stackoverflow.com/questions/49089476/any-updates-to-model-negative-binomial-distribution-data-with-gee-in-r
#https://www.rdocumentation.org/packages/geepack/versions/1.3.4/topics/geese
#https://stackoverflow.com/questions/13946540/negative-binomial-in-gee?rq=1


#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

summary2.geem <- function(object, exponentiate = FALSE, digits = 2, ...) {
  if (!is.list(object) || !"beta" %in% names(object)) {
    stop("Invalid object: Expected a model object with beta coefficients.")
  }
  
  # Initialize coefficients matrix
  Coefs <- matrix(NA, nrow = length(object$beta), ncol = 8)
  rownames(Coefs) <- object$coefnames
  colnames(Coefs) <- c("Term", "Estimates", "Model SE", "Robust SE", "Wald", "CI.lower", "CI.upper", "p.value")
  
  Coefs[, "Estimates"] <- object$beta
  
  # Handling the variance calculations
  naive <- is.null(object$var) || is.character(object$var) || any(diag(object$var) < 0)
  if (naive) {
    warning("Robust variance estimate not available or invalid. Using model-based SE.")
    Coefs[, "Robust SE"] <- sqrt(diag(object$naiv.var))
  } else {
    Coefs[, "Robust SE"] <- sqrt(diag(object$var))
  }
  
  Coefs[, "Model SE"] <- sqrt(diag(object$naiv.var))  # Model-based SE
  
  # Calculate Wald statistics
  Coefs[, "Wald"] <- Coefs[, "Estimates"] / Coefs[, "Robust SE"]
  
  # 95% CI calculations
  z_value <- qnorm((1 + 0.95) / 2)
  Coefs[, "CI.lower"] <- Coefs[, "Estimates"] - z_value * Coefs[, "Robust SE"]
  Coefs[, "CI.upper"] <- Coefs[, "Estimates"] + z_value * Coefs[, "Robust SE"]
  
  # P-value calculation
  Coefs[, "p.value"] <- round(2 * pnorm(-abs(Coefs[, "Wald"])), digits = 4)
  
  # Exponentiate estimates and CIs if specified
  if (exponentiate) {
    Coefs[, c("Estimates", "CI.lower", "CI.upper")] <- exp(Coefs[, c("Estimates", "CI.lower", "CI.upper")])
  }
  
  # Round numerical output
  decimal_format <- sprintf("%%1.%df", digits)
  
  Coefs[, c("Estimates", "Model SE", "Robust SE", "Wald", "CI.lower", "CI.upper")] <- round(Coefs[, c("Estimates", "Model SE", "Robust SE", "Wald", "CI.lower", "CI.upper")], digits = digits)
  Coefs[, c("Estimates", "Model SE", "Robust SE", "Wald", "CI.lower", "CI.upper")] <- sapply(Coefs[, c("Estimates", "Model SE", "Robust SE", "Wald", "CI.lower", "CI.upper")], function(col) {
    as.character(sprintf(decimal_format, as.numeric(col)))
  })
  # Convert matrix to data frame and keep row names
  result_df <- as.data.frame(Coefs)
  result_df[, "Term"] <- rownames(Coefs)
  row.names(result_df) <- NULL
  return(result_df)
}

#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

tidy_geese_model <- function(geese_model, conf.level = 0.95) {
  # Extract coefficients and their names
  coefficients <- geese_model$beta
  coefficient_names <- names(coefficients)
  
  # Extract variance of beta coefficients and compute standard errors
  variance_beta <- geese_model$vbeta
  std_errors <- sqrt(diag(variance_beta))
  
  # Calculate z-values and p-values
  z_values <- coefficients / std_errors
  p_values <- 2 * pnorm(-abs(z_values), lower.tail = TRUE)
  
  # Calculate confidence intervals
  alpha <- 1 - conf.level
  z <- qnorm(1 - alpha / 2)
  lower_ci <- coefficients - z * std_errors
  upper_ci <- coefficients + z * std_errors
  
  # Exponentiate coefficients and confidence intervals for odds ratios
  exp_coefficients <- exp(coefficients)
  exp_lower_ci <- exp(lower_ci)
  exp_upper_ci <- exp(upper_ci)
  
  # Create a tidy data frame
  tidy_data <- tibble::tibble(
    Term = coefficient_names,
    Estimate = exp_coefficients,
    Std.Error = std_errors,
    z.value = z_values,
    p.value = p_values,
    CI.Lower = exp_lower_ci,
    CI.Upper = exp_upper_ci
  ) %>% dplyr::mutate_at(c("Estimate", "Std.Error", "z.value", "CI.Lower","CI.Upper"),~sprintf("%1.2f",.))%>% dplyr::mutate_at(c("p.value"),~sprintf("%1.4f",.))
  
  return(tidy_data)
}

options(knitr.kable.NA = '')


#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      # record the current time before each chunk
      now <<- Sys.time()
    } else {
      # calculate the time difference after a chunk
      res <- ifelse(difftime(Sys.time(), now)>(60^2),difftime(Sys.time(), now)/(60^2),difftime(Sys.time(), now)/(60^1))
      # return a character string to show the time
      x<-ifelse(difftime(Sys.time(), now)>(60^2),paste("Time for this code chunk to run:", round(res,1), "hours"),paste("Time for this code chunk to run:", round(res,1), "minutes"))
      paste('<div class="message">', gsub('##', '\n', x),'</div>', sep = '\n')
    }
  }
}))
knitr::opts_chunk$set(time_it = TRUE)

#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

format_cells <- function(df, rows ,cols, value = c("italics", "bold", "strikethrough")){
  
  # select the correct markup
  # one * for italics, two ** for bold
  map <- setNames(c("*", "**", "~~"), c("italics", "bold", "strikethrough"))
  markup <- map[value]  
  
  for (r in rows){
    for(c in cols){
      
      # Make sure values are not factors
      df[[c]] <- as.character( df[[c]])
      
      # Update formatting
      df[r, c] <- ifelse(nchar(df[r, c])==0,"",paste0(markup, gsub(" ", "", df[r, c]), markup))
    }
  }
  
  return(df)
}
#To produce line breaks in messages and warnings
knitr::knit_hooks$set(
  error = function(x, options) {
    paste('\n\n<div class="alert alert-danger">',
          gsub('##', '\n', gsub('^##\ Error', '**Error**', x)),
          '</div>', sep = '\n')
  },
  warning = function(x, options) {
    paste('\n\n<div class="alert alert-warning">',
          gsub('##', '\n', gsub('^##\ Warning:', '**Warning**', x)),
          '</div>', sep = '\n')
  },
  message = function(x, options) {
    paste('<div class="message">',
          gsub('##', '\n', x),
          '</div>', sep = '\n')
  }
)

#_#_#_#_#_#_#_#_#_#_#_#_#_
invisible("Function to format CreateTableOne into a database")

as.data.frame.TableOne <- function(x, ...) {capture.output(print(x,
                                                                 showAllLevels = TRUE, varLabels = T,...) -> x)
  y <- as.data.frame(x)
  y$characteristic <- dplyr::na_if(rownames(x), "")
  y <- y %>%
    fill(characteristic, .direction = "down") %>%
    dplyr::select(characteristic, everything())
  rownames(y) <- NULL
  y}
#_#_#_#_#_#_#_#_#_#_#_#_#_
# Austin, P. C. (2009). The Relative Ability of Different Propensity 
# Score Methods to Balance Measured Covariates Between 
# Treated and Untreated Subjects in Observational Studies. Medical 
# Decision Making. https://doi.org/10.1177/0272989X09341755
smd_bin <- function(x,y){
  z <- x*(1-x)
  t <- y*(1-y)
  k <- sum(z,t)
  l <- k/2
  
  return((x-y)/sqrt(l))
  
}

#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_

counting_process_output<-
  function(object=NULL){
    broom::tidy(object$m, exponentiate=T, conf.int=T) %>% 
      dplyr::mutate(across(c("estimate","std.error","robust.se","statistic","conf.low","conf.high"),~sprintf("%1.2f",.))) %>% 
      dplyr::mutate(p.value= sprintf("%1.4f",p.value))
  }

#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:


if(.Platform$OS.type == "windows") withAutoprint({
  memory.size()
  memory.size(TRUE)
  memory.limit()
})
memory.limit(size=56000)
```


## 0.a. Descriptives

```{r label-variables-desc}
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true

invisible("2024-05-21: test different")
data_mine_miss_restr_proc2exp<-
data_mine_miss_restr_proc2 %>% 
left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","n_off_acq","n_off_vio","n_off_sud","n_off_oth", "n_prev_off")], by="hash_key") %>% 
  {if (nrow(.) > nrow(data_mine_miss_restr_proc2)) {message("left join added rows"); .} else .} %>% 
  dplyr::mutate(n_prev_off_bin= ifelse(n_prev_off>0,1,0)) %>% 
  dplyr::mutate(
    susinidumrec_coc = ifelse(sus_ini_mod_mvv == "Cocaine hydrochloride", 1, 0),
    susinidumrec_pbc = ifelse(sus_ini_mod_mvv == "Cocaine paste", 1, 0),
    susinidumrec_mar = ifelse(sus_ini_mod_mvv == "Marijuana", 1, 0),
    susinidumrec_otr = ifelse(sus_ini_mod_mvv == "Other", 1, 0), #sus_principal_mod
    susprindumrec_coc = ifelse(sus_principal_mod == "Cocaine hydrochloride", 1, 0),
    susprindumrec_pbc = ifelse(sus_principal_mod == "Cocaine paste", 1, 0),
    susprindumrec_mar = ifelse(sus_principal_mod == "Marijuana", 1, 0),
    susprindumrec_otr = ifelse(sus_principal_mod == "Other", 1, 0) # "susprindum_coc", "susprindum_pbc", "susprindum_mar", "susprindum_oh
  )

#"susinidumrec_otr", "susinidum_coc", "susinidum_pbc", "susinidum_mar",

  #janitor::tabyl(n_off_acq)

#(Post-Treatment)
# n_post_off_acq
# n_post_off_vio
# n_post_off_sud
# n_post_off_ot
# n_post_off

invisible("To account for variability by treatment setting, we stratified the analysis by setting: basic ambulatory GP intensive ambulatory GP residential WO intensive ambulatory WO residential")
table(subset(Base_fiscalia_v15f_grant_23_24_long2_miss_proc_multtr, is_first_occurrence==1, select= "tipo_de_plan_2_mod"))

data_mine_miss_restr_proc2exp %>% 
  group_by(hash_key) %>% 
  summarise(min(fech_ing_num)) %>% nrow()
#13317
subset(data_mine_miss_restr_proc2 , is_first_occurrence==1) %>% nrow()
#13317
data_mine_miss_restr_proc2_baseline<-
  subset(data_mine_miss_restr_proc2exp , is_first_occurrence==1) 


variables_vector <- c("tr_outcome", "policonsumo2", "comp_bpsc_y3_severe",
                      "less_90d_tr1", "log_dias_treat_imp_sin_na",
                      "edad_al_ing_1", "ano_nac_corr", "susinidumrec_coc", 
                      "susinidumrec_pbc", "susinidumrec_mar", "susinidumrec_otr", 
                      "psycom_dum_study", "psycom_dum_with", "freq_cons_dum_5day", 
                      "cond_oc_dum_2inact", "cond_oc_dum_3unemp", "susprindumrec_coc", 
                      "susprindumrec_pbc", "susprindumrec_mar", "susprindumrec_otr")#,"lag_comp_bpsc_y3_severe", "lag_less_90d_tr1", "log_lag_dias_treat_imp_sin_na", "lag_policonsumo2", "lag_tr_outcome")

```

```{r label-variables-desc2}
#| class-output: center-table
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true

attr(data_mine_miss_restr_proc2_baseline$tr_outcome,"label") <- "Complete status of treatment (binary)"
attr(data_mine_miss_restr_proc2_baseline$tr_outcome,"label") <- "Complete status of treatment (binary)"
attr(data_mine_miss_restr_proc2_baseline$policonsumo2,"label") <- "Polysubstance use"
attr(data_mine_miss_restr_proc2_baseline$comp_bpsc_y3_severe,"label") <- "Biopsychosocial compromise (Severe)"
attr(data_mine_miss_restr_proc2_baseline$less_90d_tr1,"label") <- "Treatment duration (binary) (<90 days)"
attr(data_mine_miss_restr_proc2_baseline$log_dias_treat_imp_sin_na,"label") <- "Treatment duration (log-scaled days)"
attr(data_mine_miss_restr_proc2_baseline$edad_al_ing_1,"label") <- "Age at admission to treatment"
attr(data_mine_miss_restr_proc2_baseline$ano_nac_corr,"label") <- "Birth year"
attr(data_mine_miss_restr_proc2_baseline$susinidumrec_coc,"label") <- "Primary substance (initial diagnosis): cocaine hydrochloride"
attr(data_mine_miss_restr_proc2_baseline$susinidumrec_pbc,"label") <- "Primary substance (initial diagnosis): cocaine base paste"
attr(data_mine_miss_restr_proc2_baseline$susinidumrec_mar,"label") <- "Primary substance (initial diagnosis): marijuana"
attr(data_mine_miss_restr_proc2_baseline$susinidumrec_otr,"label") <- "Primary substance (initial diagnosis): other"
attr(data_mine_miss_restr_proc2_baseline$psycom_dum_study,"label") <- "Psychiatric comorbidity (ICD-10): In study"
attr(data_mine_miss_restr_proc2_baseline$psycom_dum_with,"label") <- "Psychiatric comorbidity (ICD-10): Diagnosed"
attr(data_mine_miss_restr_proc2_baseline$freq_cons_dum_5day,"label") <- "Daily frequence of primary substance use at admission"
attr(data_mine_miss_restr_proc2_baseline$cond_oc_dum_2inact,"label") <- "Occupational Status: Inactive"
attr(data_mine_miss_restr_proc2_baseline$cond_oc_dum_3unemp,"label") <- "Occupational Status: Unemployed"
attr(data_mine_miss_restr_proc2_baseline$susprindumrec_coc,"label") <- "Primary substance at admission to treatment: cocaine hydrochloride"
attr(data_mine_miss_restr_proc2_baseline$susprindumrec_pbc,"label") <- "Primary substance at admission to treatment: cocaine base paste"
attr(data_mine_miss_restr_proc2_baseline$susprindumrec_mar,"label") <- "Primary substance at admission to treatment: marijuana"
attr(data_mine_miss_restr_proc2_baseline$susprindumrec_otr,"label") <- "Primary substance at admission to treatment: other"
attr(data_mine_miss_restr_proc2_baseline$tipo_de_plan_2_mod,"label") <- "Treatment setting"

invisible("Table for imputed dataset with selected covariates")

library(tableone)

vars <- setdiff(c(variables_vector,"tipo_de_plan_2_mod"), "policonsumo2")
factorVars <- setdiff(variables_vector, c("policonsumo2", "edad_al_ing_1", "log_dias_treat_imp_sin_na", "ano_nac_corr"))

tableOne <- CreateTableOne(vars = vars, data = data_mine_miss_restr_proc2_baseline,
                           factorVars = factorVars, strata = "policonsumo2", 
                           addOverall = TRUE,  # <-- This is the key addition
                           includeNA = TRUE,
                           test = TRUE) # Remove statistical tests for speed

print(tableOne, smd = TRUE) # Calculate SMD separately if needed

smd_bin(
  prop.table(table(data_mine_miss_restr_proc2_baseline$susprindum_mar[data_mine_miss_restr_proc2_baseline$policonsumo==0]))[[2]],
  prop.table(table(data_mine_miss_restr_proc2_baseline$susprindum_mar[data_mine_miss_restr_proc2_baseline$policonsumo==1]))[[2]]
)
smd_bin(
    prop.table(table(data_mine_miss_restr_proc2_baseline$comp_bpsc_y3_severe [data_mine_miss_restr_proc2_baseline$policonsumo==0]))[[2]],
    prop.table(table(data_mine_miss_restr_proc2_baseline$comp_bpsc_y3_severe [data_mine_miss_restr_proc2_baseline$policonsumo==1]))[[2]]
)

folder_path <- ifelse(dir.exists("E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/"),
                      "E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/",
                      "C:/Users/CISS Fondecyt/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/")

as.data.frame.TableOne(tableOne, smd=T, nonnormal= T)%>% 
    dplyr::mutate(char2=characteristic) %>% 
    tidyr::fill(char2) %>% 
    dplyr::select(char2,everything()) %>% 
    dplyr::mutate(level=ifelse(is.na(level),"[Missing]",level)) %>% 
    dplyr::mutate(char2=dplyr::case_when(characteristic=="NA"~NA_character_,TRUE~as.character(characteristic))) %>% 
    format_cells(1, 1:length(names(.)), "bold") %>%
    dplyr::select(-1) %>% 
    dplyr::mutate_all(~ str_replace_all(., pattern = "\\( ", replacement = "\\(")) %>% 
    dplyr::mutate_all(~ str_trim(.)) %>% 
    dplyr::select(characteristic, level, `0`, `1`, Overall, SMD)%>% 
  {
    knitr::kable(.,size=10, format="html",caption= "Summary descriptives, Polysubstance(1) and no Polysubstance use (0)", escape=T)%>% 
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
     kableExtra::scroll_box(width = "100%", height = "375px")  
    write.table(.,paste0(folder_path,"baseline_psu_desc_subsamp_smd.csv"), dec=",", sep="\t")
  }
```

```{r exp-surv1}
#| class-output: center-table
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true

  rbind.data.frame(
    cbind.data.frame(
      type= "PSU at admission and at least one dropout from the first admission",
    biostat3::survRate(Surv(cens_time, sum_tr_outcomes>0) ~ policonsumo2, 
                       data= data_mine_miss_restr_proc2 %>% 
                        dplyr::group_by(hash_key) %>% 
                        dplyr::mutate(sum_tr_outcomes=sum(tr_outcome==1,na.rm=T)) %>% 
                        dplyr::filter(is_first_occurrence==1) %>% 
                        dplyr::ungroup())  %>% 
      dplyr::mutate(across(c("rate", "lower", "upper"),~sprintf("%1.2f",.*1000)))
    ),
    cbind.data.frame(
      type= "PSU at admission and first dropout",
    biostat3::survRate(Surv(cens_time, tr_outcome==1) ~ policonsumo2, 
                       data= data_mine_miss_restr_proc2 %>% 
                        dplyr::group_by(hash_key) %>% 
                        dplyr::mutate(sum_tr_outcomes=sum(tr_outcome==1,na.rm=T)) %>% 
                        dplyr::filter(is_first_occurrence==1) %>% 
                        dplyr::ungroup())  %>% 
      dplyr::mutate(across(c("rate", "lower", "upper"),~sprintf("%1.2f",.*1000))) 
    ),
    cbind.data.frame(
      type= "At least one treatment reporting PSU and at least one dropout from the first admission",
    biostat3::survRate(Surv(cens_time, sum_tr_outcomes>0) ~ policonsumo2, 
                       data= data_mine_miss_restr_proc2 %>% 
                        dplyr::group_by(hash_key) %>% 
                        dplyr::mutate(sum_tr_outcomes=sum(tr_outcome==1,na.rm=T),
                                      sum_policonsumo2=sum(policonsumo2==1,na.rm=T)) %>% 
                        dplyr::filter(is_first_occurrence==1) %>% 
                        dplyr::ungroup() %>% dplyr::mutate(policonsumo2=ifelse(sum_policonsumo2>0,1,0)))  %>% 
      dplyr::mutate(across(c("rate", "lower", "upper"),~sprintf("%1.2f",.*1000))) 
    ),
    cbind.data.frame(
      type= "At least one treatment reporting PSU and first dropout",
    biostat3::survRate(Surv(cens_time, tr_outcome==1) ~ policonsumo2, 
                       data= data_mine_miss_restr_proc2 %>% 
                        dplyr::group_by(hash_key) %>% 
                        dplyr::mutate(sum_tr_outcomes=sum(tr_outcome==1,na.rm=T),
                                      sum_policonsumo2=sum(policonsumo2==1,na.rm=T)) %>% 
                        dplyr::filter(is_first_occurrence==1) %>% 
                        dplyr::ungroup() %>% dplyr::mutate(policonsumo2=ifelse(sum_policonsumo2>0,1,0)))  %>% 
      dplyr::mutate(across(c("rate", "lower", "upper"),~sprintf("%1.2f",.*1000))) 
    )    
  ) %>%  
    dplyr::mutate(`IR (95% CI)`= paste0(rate, " (", lower,", ", upper,")")) %>% 
    dplyr::select(-any_of(c("rate", "lower", "upper"))) %>% 
    dplyr::mutate(across(c("tstop", "event"),~ format(as.numeric(.), big.mark=","))) %>% 
    
  {
    copiar_nombres2(.)
    write.table(.,paste0(folder_path,"person_time_irrs.csv"), dec=",", sep="\t")
    knitr::kable(.,"html", caption= "Incidence rates (per 1.000 person-months)")%>% 
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
     kableExtra::scroll_box(width = "100%", height = "375px")  
  }
```


## 0.b. IIWs

```{r iiw-summary}
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true

rbind.data.frame(
  cbind.data.frame(model= "Primary (no corrections, lag=0)", t(matrix(summary(data_mine_miss_restr_proc2$iiw_nocorr_st)))),
  cbind.data.frame(model= "Alternative (no corrections, lag=1)", t(matrix(summary(data_mine_miss_restr_proc2$iiw_nocorr_alt_st)))),
  cbind.data.frame(model= "Primary (after PH, lag=0)", t(matrix(summary(data_mine_miss_restr_proc2_iiw_after_ph$iiw_after_ph_st)))),
  cbind.data.frame(model= "Alternative (after PH, lag=1)", t(matrix(summary(data_mine_miss_restr_proc2_iiw_after_ph_alt$iiw_after_ph_st)))),
  cbind.data.frame(model= "Primary (strata, lag=0)", t(matrix(summary(data_mine_miss_proc2_iiw_strata_alt$iiw_strata_st)))),
  cbind.data.frame(model= "Alternative (strata, lag=1)", t(matrix(summary(data_mine_miss_proc2_iiw_strata_alt_alt$iiw_strata_st))))
) %>%  #Min.	First quartile	Median	Mean	Third quartile	Max.
  dplyr::mutate_if(is.numeric, ~sprintf("%1.2f",.)) %>% 
  dplyr::mutate(model= dplyr::case_when(model== "Primary (no corrections, lag=0)"~ "No time-varying coefficients, lagged covariates fixed in 0", model== "Alternative (no corrections, lag=1)"~ "No time-varying coefficients, lagged covariates fixed in 1", model== "Primary (after PH, lag=0)"~ "With time-varying coefficients, lagged covariates fixed in 0", model== "Alternative (after PH, lag=1)"~ "With time-varying coefficients, lagged covariates fixed in 1", model== "Primary (strata, lag=0)"~ "Stratified by follow-up intervals, lagged covariates fixed in 0", model== "Alternative (strata, lag=1)"~ "Stratified by follow-up intervals, lagged covariates fixed in 1")) %>% 
  {
    copiar_nombres2(.)
    write.table(.,paste0(folder_path,"iiws_20240516.csv"), dec=",", sep="\t")
    knitr::kable(.,size=10, format="html",caption= "Descriptive characterization of inverse intensity weights", escape=T, col.names= c("Visit intensity model", "Min.",	"First quartile",	"Median",	"Mean",	"Third quartile",	"Max."))%>% 
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
     kableExtra::scroll_box(width = "100%", height = "375px")  
  }
```


## 0.c. Intensity model

```{r intensity-model}
#| class-output: center-table
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true
#Cox Counting process


#https://rdrr.io/github/gforge/Greg/src/R/tidy.rms.R
source(paste0(folder_path,"tidy_rms.R"))

term_mapping <- data.frame(
  term = c("lag_tr_outcome", "lag_comp_bpsc_y3_severe", "lag_less_90d_tr1", "log_lag_dias_treat_imp_sin_na", "lag_policonsumo2", "edad_al_ing_1", "ano_nac_corr", "susinidumrec_coc", "susinidumrec_pbc", "susinidumrec_mar", "susinidumrec_otr", "psycom_dum_study", "psycom_dum_with", "freq_cons_dum_5day", "cond_oc_dum_2inact", "cond_oc_dum_3unemp", "susprindumrec_coc", "susprindumrec_pbc", "susprindumrec_mar", "susprindumrec_otr",  "lag_tr_outcome_rec", "lag_less_90d_tr1_rec", "lag_comp_bpsc_y3_severe_rec", "susinidum_coc_rec2", "psycom_dum_with_rec2"),
  term_label = c("Treatment outcome of the previous treatment", "Previous biopsychosocial compromise (severe)", 
                 "Previous treatment duration (<90 days)", "Previous treatment duration (in logarithmic scaled days)", 
                 "Polysubstance use status of the previous treatment", "Age at admission to treatment", "Birth year", 
                  "Primary substance (initial diagnosis), cocaine", "Primary substance (initial diagnosis), cocaine base paste", "Primary substance (initial diagnosis), marijuana", "Primary substance (initial diagnosis), other", "Psychiatric comorbidity (diagnosis unknown or under study)", "Psychiatric comorbidity (confirmed comorbidity)", "Daily frequence of primary substance use at admission", "Occupational status (inactive)", "Occupational status (unemployed)", "Primary substance at admission to treatment (cocaine hydrochloride)", "Primary substance at admission to treatment (cocaine base paste)", "Primary substance at admission to treatment (marijuana)", "Primary substance at admission to treatment (other)", "Treatment outcome of the previous treatment (recoded for interaction with time)", "Previous biopsychosocial compromise (severe, recoded for interaction with time)", "Previous treatment duration (<90 days, recoded for interaction with time)", "Primary substance (initial diagnosis), cocaine (recoded for interaction with time)", "Psychiatric comorbidity (confirmed comorbidity, recoded for interaction with time)")
)

cph_nocorr<-
  cph(Surv(lag_time,time,event)~
        cluster(id)+ 
        lag_tr_outcome+
        lag_comp_bpsc_y3_severe+
        lag_less_90d_tr1+
        log_lag_dias_treat_imp_sin_na +
        lag_policonsumo2 + 
        edad_al_ing_1 + 
        ano_nac_corr + 
        susinidumrec_otr +
        susinidumrec_coc +
        susinidumrec_pbc +
        susinidumrec_mar +
        psycom_dum_study +
        psycom_dum_with +
        freq_cons_dum_5day +
        cond_oc_dum_2inact +
        cond_oc_dum_3unemp +
        susprindumrec_coc +
        susprindumrec_pbc +
        susprindumrec_mar +
        susprindumrec_otr +    
        strat(tipo_de_plan_2_mod),
      data= data_mine_miss_restr_proc2exp %>% data.table::as.data.table() %>% data.frame(), 
      x=TRUE, y=TRUE, surv=TRUE, iter.max = 250*4, tol = 1e-6)

cph_after_ph<-
cph(Surv(lag_time,time,event==1)~ 
                  cluster(id)+ 
                  lag_tr_outcome_rec +
                  log_lag_dias_treat_imp_sin_na +
                  lag_less_90d_tr1_rec+
                  lag_comp_bpsc_y3_severe_rec + 
                  lag_policonsumo2 + 
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidum_coc_rec2 +
                  susinidumrec_otr +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_with_rec2 +
                  psycom_dum_study + 
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar +
                  susprindumrec_otr +    
                  strat(tipo_de_plan_2_mod), 
                data=data_mine_miss_restr_proc2exp, 
                x=TRUE, y=TRUE, surv=TRUE, iter.max = 250*4, tol = 1e-6)

model_after_time_strat<-
cph(Surv(lag_time,time,event)~
          cluster(id)+ 
          lag_tr_outcome+
          lag_comp_bpsc_y3_severe+
          lag_less_90d_tr1+
          log_lag_dias_treat_imp_sin_na +
          lag_policonsumo2 + 
          edad_al_ing_1 + 
          ano_nac_corr + 
          susinidumrec_otr +
          susinidumrec_coc +
          susinidumrec_pbc +
          susinidumrec_mar +
          psycom_dum_study +
          psycom_dum_with +
          freq_cons_dum_5day +
          cond_oc_dum_2inact +
          cond_oc_dum_3unemp +
          susprindumrec_coc +
          susprindumrec_pbc +
          susprindumrec_mar +
          susprindumrec_otr +
          strat(tipo_de_plan_2_mod)+
          strat(time_interval3),
    data= data_mine_miss_restr_proc2exp %>% data.table::as.data.table() %>% data.frame(), 
    x=TRUE, y=TRUE, surv=TRUE, iter.max = 250*4, tol = 1e-6)

model_after_time_strat_alt<-
cph(Surv(lag_time,time,event)~
          cluster(id)+ 
          lag_tr_outcome+
          lag_comp_bpsc_y3_severe+
          lag_less_90d_tr1+
          log_lag_dias_treat_imp_sin_na +
          lag_policonsumo2 + 
          edad_al_ing_1 + 
          ano_nac_corr + 
          susinidumrec_otr +
          susinidumrec_coc +
          susinidumrec_pbc +
          susinidumrec_mar +
          psycom_dum_study +
          psycom_dum_with +
          freq_cons_dum_5day +
          cond_oc_dum_2inact +
          cond_oc_dum_3unemp +
          susprindumrec_otr +
          susprindumrec_coc +
          susprindumrec_pbc +
          susprindumrec_mar +
          strat(tipo_de_plan_2_mod)+
          strat(time_interval3_alt),
    data= data_mine_miss_restr_proc2exp %>% data.table::as.data.table() %>% data.frame(), 
    x=TRUE, y=TRUE, surv=TRUE, iter.max = 250*4, tol = 1e-6)

invisible("Problemático")
# broom::tidy(coxph(Surv(lag_time,time,event==1)~ 
#         cluster(id)+ 
#         lag_tr_outcome_rec +
#         log_lag_dias_treat_imp_sin_na +
#         lag_less_90d_tr1_rec+
#         lag_comp_bpsc_y3_severe_rec + 
#         lag_policonsumo2 + 
#         edad_al_ing_1 + 
#         ano_nac_corr + 
#         susinidum_coc_rec2 +
#         susinidumrec_otr +
#         susinidum_pbc +
#         susinidum_mar +
#         psycom_dum_with_rec2 +
#         psycom_dum_study + 
#         freq_cons_dum_5day +
#         cond_oc_dum_2inact +
#         cond_oc_dum_3unemp +
#         susprindum_oh +
#         susprindum_coc +
#         susprindum_pbc +
#         susprindum_mar+
#         strata(tipo_de_plan_2_mod), 
#     data=data_mine_miss_restr_proc2), exponentiate=T, conf.int=T)

models_hr_table2<-
rbind.data.frame(
cbind.data.frame(model="No correction", tidy.rms(cph_nocorr, conf.int=T, exponentiate=T)[, c("term","estimate", "conf.low", "conf.high")]%>% 
  dplyr::mutate_if(is.numeric, ~sprintf("%1.2f",.))),
cbind.data.frame(model="After PH", tidy.rms(cph_after_ph, conf.int=T, exponentiate=T)[, c("term","estimate", "conf.low", "conf.high")]%>% 
  dplyr::mutate_if(is.numeric, ~sprintf("%1.2f",.))),
cbind.data.frame(model="Stratifying", tidy.rms(model_after_time_strat, conf.int=T, exponentiate=T)[, c("term","estimate", "conf.low", "conf.high")]%>% 
  dplyr::mutate_if(is.numeric, ~sprintf("%1.2f",.))),
cbind.data.frame(model="Stratifying, alt strata", tidy.rms(model_after_time_strat_alt, conf.int=T, exponentiate=T)[, c("term","estimate", "conf.low", "conf.high")] %>% 
  dplyr::mutate_if(is.numeric, ~sprintf("%1.2f",.)))
)

models_hr_table2$term_label <- term_mapping$term_label[match(models_hr_table2$term, term_mapping$term)]

models_hr_table2%>%
  dplyr::select(term_label, everything()) %>% 
  {
    #copiar_nombres2(.)
    write.table(.,paste0(folder_path,"coxph_intensity_model_prev.csv"), dec=",", sep="\t")
    knitr::kable(.,size=10, format="html",caption= "Intensity model", escape=T)%>% 
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
     kableExtra::scroll_box(width = "100%", height = "375px")  
  }

```



# GEE


## 1. No correction

```{r}
plan_names <- attr(table(data_mine_miss_restr_proc2$tipo_de_plan_2_mod),"dimnames")[[1]]
```

### 1.1. No correciton, no weight 

Initialize a list to store models

```{r}
nocorr_nowgt_list <- list()
```

Loop over each unique plan name to fit a model

```{r gee11, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, #origen_ingreso_mod fis_comorbidity_icd_10 dg_trs_cons_sus_or
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  nocorr_nowgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```



#### 1.1.1 No correction, no weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_nocorr_nowgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee111, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar+
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = current_data,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_nocorr_nowgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```

#### 1.1.2 No correction, no weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(0.2, 16, by = 0.1)
```

Initialize a list to store models and their QICs

```{r}
geem2_nocorr_nowgt_list <- list()
```

Loop over each unique plan name to fit models



```{r gee112, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                    susprindumrec_coc +
                    susprindumrec_pbc +
                    susprindumrec_mar+
                    susprindumrec_otr, # Include relevant predictors
                  id = id, 
                  data = current_data,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_nocorr_nowgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


### 1.2. No correction, weight 

Initialize a list to store models

```{r}
nocorr_wgt_list <- list()
```

Loop over each unique plan name to fit a model



```{r gee12, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 weight = current_data$iiw_nocorr_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  nocorr_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


#### 1.2.1 No correction, no weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_nocorr_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee121, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar +
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = current_data,
                weight = current_data$iiw_nocorr_st,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_nocorr_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```

#### 1.2.2 No correction, no weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_nocorr_wgt_list <- list()
```

Loop over each unique plan name to fit models


```{r gee122, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                    susprindumrec_coc +
                    susprindumrec_pbc +
                    susprindumrec_mar +
                    susprindumrec_otr, # Include relevant predictors
                  id = id, 
                  data = current_data,
                  weight = current_data$iiw_nocorr_st,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_nocorr_wgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan


```{r}
#| class-output: center-table

print(geem2_nocorr_wgt_list[[1]])
```


### 1.3. No correction, alt. weight 

Initialize a list to store models

```{r}
nocorr_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee13, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 weight = current_data$iiw_nocorr_alt_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  nocorr_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```

#### 1.3.1 No correction, alt weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_nocorr_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee131, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar +
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = current_data,
                weight = current_data$iiw_nocorr_alt_st,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_nocorr_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


#### 1.3.2 No correction, alt weight, GEEM Negative binomial 


```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_nocorr_alt_wgt_list <- list()
```

Loop over each unique plan name to fit models


```{r gee132, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                    susprindumrec_coc +
                    susprindumrec_pbc +
                    susprindumrec_mar +
                    susprindumrec_otr, # Include relevant predictors
                  id = id, 
                  data = current_data,
                  weight = current_data$iiw_nocorr_alt_st,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_nocorr_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan

```{r}
#| class-output: center-table

print(geem2_nocorr_alt_wgt_list[[1]])
```


## 2. After PH

### 2.1. After PH, no weight 

Initialize a list to store models

```{r}
afterph_nowgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee21, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

data_mine_miss_restr_proc2exp_iiw_after_ph <-
  data_mine_miss_restr_proc2_iiw_after_ph %>% 
left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","n_off_acq","n_off_vio","n_off_sud","n_off_oth", "n_prev_off")], by="hash_key") %>% 
  {if (nrow(.) > nrow(data_mine_miss_restr_proc2_iiw_after_ph)) {message("left join added rows"); .} else .} %>% 
  dplyr::mutate(n_prev_off_bin= ifelse(n_prev_off>0,1,0)) %>% 
  dplyr::mutate(
    susinidumrec_coc = ifelse(sus_ini_mod_mvv == "Cocaine hydrochloride", 1, 0),
    susinidumrec_pbc = ifelse(sus_ini_mod_mvv == "Cocaine paste", 1, 0),
    susinidumrec_mar = ifelse(sus_ini_mod_mvv == "Marijuana", 1, 0),
    susinidumrec_otr = ifelse(sus_ini_mod_mvv == "Other", 1, 0), #sus_principal_mod
    susprindumrec_coc = ifelse(sus_principal_mod == "Cocaine hydrochloride", 1, 0),
    susprindumrec_pbc = ifelse(sus_principal_mod == "Cocaine paste", 1, 0),
    susprindumrec_mar = ifelse(sus_principal_mod == "Marijuana", 1, 0),
    susprindumrec_otr = ifelse(sus_principal_mod == "Other", 1, 0) # "susprindum_coc", "susprindum_pbc", "susprindum_mar", "susprindum_oh
  )

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 #weight= current_data$iiw_nocorr_alt_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  afterph_nowgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


##### 2.1.1 After PH, no weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_afterph_nowgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee211, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar +
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = current_data,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_afterph_nowgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


##### 2.1.2 After PH, no weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_afterph_nowgt_list <- list()
```

Loop over each unique plan name to fit models


```{r gee212, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                    susprindumrec_coc +
                    susprindumrec_pbc +
                    susprindumrec_mar +
                    susprindumrec_otr, # Include relevant predictors
                  id = id, 
                  data = current_data,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_afterph_nowgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan


```{r}
#| class-output: center-table

print(geem2_nocorr_nowgt_list[[1]])
```


As expected, QIC is equal, because the covariates and observations were the same

#### 2.2. After PH, weight 

Initialize a list to store models

```{r}
afterph_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee22, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 weight = current_data$iiw_after_ph_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  afterph_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


##### 2.2.1 After PH, weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_afterph_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee221, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindum_mar +
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = current_data,
                weight = current_data$iiw_after_ph_st,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_afterph_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


##### 2.2.2 After PH, weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_afterph_wgt_list <- list()
```

Loop over each unique plan name to fit models


```{r gee222, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                    susprindumrec_coc +
                    susprindumrec_pbc +
                    susprindumrec_mar +
                    susprindumrec_otr, # Include relevant predictors
                  id = id, 
                  data = current_data,
                  weight = current_data$iiw_after_ph_st,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_afterph_wgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan


```{r}
#| class-output: center-table

print(geem2_afterph_wgt_list[[1]])
```


#### 2.3. After PH, alt. weight 

Initialize a list to store models

```{r}
afterph_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee23, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

data_mine_miss_restr_proc2exp_iiw_after_ph_alt <-
  data_mine_miss_restr_proc2_iiw_after_ph_alt %>% 
left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","n_off_acq","n_off_vio","n_off_sud","n_off_oth", "n_prev_off")], by="hash_key") %>% 
  {if (nrow(.) > nrow(data_mine_miss_restr_proc2_iiw_after_ph_alt)) {message("left join added rows"); .} else .} %>% 
  dplyr::mutate(n_prev_off_bin= ifelse(n_prev_off>0,1,0)) %>% 
  dplyr::mutate(
    susinidumrec_coc = ifelse(sus_ini_mod_mvv == "Cocaine hydrochloride", 1, 0),
    susinidumrec_pbc = ifelse(sus_ini_mod_mvv == "Cocaine paste", 1, 0),
    susinidumrec_mar = ifelse(sus_ini_mod_mvv == "Marijuana", 1, 0),
    susinidumrec_otr = ifelse(sus_ini_mod_mvv == "Other", 1, 0), #sus_principal_mod
    susprindumrec_coc = ifelse(sus_principal_mod == "Cocaine hydrochloride", 1, 0),
    susprindumrec_pbc = ifelse(sus_principal_mod == "Cocaine paste", 1, 0),
    susprindumrec_mar = ifelse(sus_principal_mod == "Marijuana", 1, 0),
    susprindumrec_otr = ifelse(sus_principal_mod == "Other", 1, 0) # "susprindum_coc", "susprindum_pbc", "susprindum_mar", "susprindum_oh
  )


for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 weight = current_data$iiw_after_ph_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  afterph_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


##### 2.3.1 After PH, alt weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_afterph_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee231, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar +
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = current_data,
                weight = current_data$iiw_after_ph_st,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_afterph_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```

##### 2.3.2 After PH, alt weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_afterph_alt_wgt_list <- list()
```

Loop over each unique plan name to fit models

```{r gee232, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp_iiw_after_ph_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                    susprindumrec_coc +
                    susprindumrec_pbc +
                    susprindumrec_mar +
                    susprindumrec_otr, # Include relevant predictors
                  id = id, 
                  data = current_data,
                  weight = current_data$iiw_after_ph_st,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_afterph_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```

Check the result for a particular plan


```{r}
#| class-output: center-table

print(geem2_afterph_alt_wgt_list[[1]])
```


## 3. Stratifying

### 3.1. Stratifying, no weight 

Initialize a list to store models

```{r}
strata_nowgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee31, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table


data_mine_miss_proc2exp_iiw_strata <-
  data_mine_miss_proc2_iiw_strata %>% 
left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","n_off_acq","n_off_vio","n_off_sud","n_off_oth", "n_prev_off")], by="hash_key") %>% 
  {if (nrow(.) > nrow(data_mine_miss_restr_proc2_iiw_after_ph_alt)) {message("left join added rows"); .} else .} %>% 
  dplyr::mutate(n_prev_off_bin= ifelse(n_prev_off>0,1,0)) %>% 
  dplyr::mutate(
    susinidumrec_coc = ifelse(sus_ini_mod_mvv == "Cocaine hydrochloride", 1, 0),
    susinidumrec_pbc = ifelse(sus_ini_mod_mvv == "Cocaine paste", 1, 0),
    susinidumrec_mar = ifelse(sus_ini_mod_mvv == "Marijuana", 1, 0),
    susinidumrec_otr = ifelse(sus_ini_mod_mvv == "Other", 1, 0), #sus_principal_mod
    susprindumrec_coc = ifelse(sus_principal_mod == "Cocaine hydrochloride", 1, 0),
    susprindumrec_pbc = ifelse(sus_principal_mod == "Cocaine paste", 1, 0),
    susprindumrec_mar = ifelse(sus_principal_mod == "Marijuana", 1, 0),
    susprindumrec_otr = ifelse(sus_principal_mod == "Other", 1, 0) # "susprindum_coc", "susprindum_pbc", "susprindum_mar", "susprindum_oh
  )

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 #weight= current_data$iiw_nocorr_alt_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  strata_nowgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```

#### 3.1.1 Stratifying, no weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_strata_nowgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee311, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                  susprindumrec_coc +
                  susprindumrec_pbc +
                  susprindumrec_mar +
                  susprindumrec_otr, # Include relevant predictors
                id = id, 
                data = current_data,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_strata_nowgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


#### 3.1.2 Stratifying, no weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_strata_nowgt_list <- list()
```

Loop over each unique plan name to fit models


```{r gee312, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                    susprindumrec_coc +
                    susprindumrec_pbc +
                    susprindumrec_mar +
                    susprindumrec_otr, # Include relevant predictors
                  id = id, 
                  data = current_data,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_strata_nowgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan


```{r}
#| class-output: center-table

print(geem2_nocorr_nowgt_list[[1]])
```


### 3.2. Stratifying, weight 

Initialize a list to store models

```{r}
strata_wgt_list <- list()
```

Loop over each unique plan name to fit a model

```{r gee32, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 weight = current_data$iiw_strata_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  strata_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


#### 3.2.1 Stratifying, weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_strata_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee321, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                id = id, 
                data = current_data,
                weight = current_data$iiw_strata_st,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_strata_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```

#### 3.2.2 Stratifying, weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_strata_wgt_list <- list()
```

Loop over each unique plan name to fit models


```{r gee322, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                  id = id, 
                  data = current_data,
                  weight= current_data$iiw_strata_st,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_strata_wgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan


```{r}
#| class-output: center-table

print(geem2_strata_wgt_list[[1]])
```


### 3.3. Stratifying, alt. weight 

Initialize a list to store models

```{r}
strata_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee33, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table


data_mine_miss_proc2exp_iiw_strata_alt <-
  data_mine_miss_proc2_iiw_strata_alt %>% 
left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","n_off_acq","n_off_vio","n_off_sud","n_off_oth", "n_prev_off")], by="hash_key") %>% 
  {if (nrow(.) > nrow(data_mine_miss_restr_proc2_iiw_after_ph_alt)) {message("left join added rows"); .} else .} %>% 
  dplyr::mutate(n_prev_off_bin= ifelse(n_prev_off>0,1,0)) %>% 
  dplyr::mutate(
    susinidumrec_coc = ifelse(sus_ini_mod_mvv == "Cocaine hydrochloride", 1, 0),
    susinidumrec_pbc = ifelse(sus_ini_mod_mvv == "Cocaine paste", 1, 0),
    susinidumrec_mar = ifelse(sus_ini_mod_mvv == "Marijuana", 1, 0),
    susinidumrec_otr = ifelse(sus_ini_mod_mvv == "Other", 1, 0), #sus_principal_mod
    susprindumrec_coc = ifelse(sus_principal_mod == "Cocaine hydrochloride", 1, 0),
    susprindumrec_pbc = ifelse(sus_principal_mod == "Cocaine paste", 1, 0),
    susprindumrec_mar = ifelse(sus_principal_mod == "Marijuana", 1, 0),
    susprindumrec_otr = ifelse(sus_principal_mod == "Other", 1, 0) # "susprindum_coc", "susprindum_pbc", "susprindum_mar", "susprindum_oh
  )


for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 weight = current_data$iiw_strata_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  strata_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


#### 3.3.1 Stratifying, alt weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_strata_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee331, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                id = id, 
                data = current_data,
                weight = current_data$iiw_strata_st,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_strata_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
#Alternative, better than main
```



```{r}
#| class-output: center-table

print(geem_strata_alt_wgt_list[[1]])
```


#### 3.3.2 No correction, alt weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_strata_alt_wgt_list <- list()
```

Loop over each unique plan name to fit models


```{r gee332, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                  id = id, 
                  data = current_data,
                  weight = current_data$iiw_strata_st,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_strata_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan


```{r}
#| class-output: center-table

print(geem2_strata_alt_wgt_list[[1]])
```


### 3.4. Stratifying, 2nd alt. weight 

Initialize a list to store models

```{r}
strata_alt_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model


```{r gee34, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table


data_mine_miss_proc2exp_iiw_strata_alt_alt <-
  data_mine_miss_proc2_iiw_strata_alt_alt %>% 
left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","n_off_acq","n_off_vio","n_off_sud","n_off_oth", "n_prev_off")], by="hash_key") %>% 
  {if (nrow(.) > nrow(data_mine_miss_restr_proc2_iiw_after_ph_alt)) {message("left join added rows"); .} else .} %>% 
  dplyr::mutate(n_prev_off_bin= ifelse(n_prev_off>0,1,0)) %>% 
  dplyr::mutate(
    susinidumrec_coc = ifelse(sus_ini_mod_mvv == "Cocaine hydrochloride", 1, 0),
    susinidumrec_pbc = ifelse(sus_ini_mod_mvv == "Cocaine paste", 1, 0),
    susinidumrec_mar = ifelse(sus_ini_mod_mvv == "Marijuana", 1, 0),
    susinidumrec_otr = ifelse(sus_ini_mod_mvv == "Other", 1, 0), #sus_principal_mod
    susprindumrec_coc = ifelse(sus_principal_mod == "Cocaine hydrochloride", 1, 0),
    susprindumrec_pbc = ifelse(sus_principal_mod == "Cocaine paste", 1, 0),
    susprindumrec_mar = ifelse(sus_principal_mod == "Marijuana", 1, 0),
    susprindumrec_otr = ifelse(sus_principal_mod == "Other", 1, 0) # "susprindum_coc", "susprindum_pbc", "susprindum_mar", "susprindum_oh
  )


for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata_alt_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geese(tr_outcome ~ policonsumo2 +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                 id = id, 
                 data = current_data,
                 family = poisson(), 
                 weight = current_data$iiw_strata_st,
                 corstr = "independence", 
                 jack = T)
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  strata_alt_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


#### 3.4.1 Stratifying, alt weight, GEEM Poisson 

Initialize a list to store models

```{r}
geem_strata_alt_alt_wgt_list <- list()
```

Loop over each unique plan name to fit a model

```{r gee341, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata_alt_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset using geem
  model <- geem(tr_outcome ~ policonsumo2 +
                  comp_bpsc_y3_severe+
                  edad_al_ing_1 + 
                  ano_nac_corr + 
                  susinidumrec_otr +
                  susinidumrec_coc +
                  susinidumrec_pbc +
                  susinidumrec_mar +
                  psycom_dum_study +
                  psycom_dum_with +
                  freq_cons_dum_5day +
                  cond_oc_dum_2inact +
                  cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                id = id, 
                data = current_data,
                weight = current_data$iiw_strata_st,
                family = poisson("log"), 
                corstr = "independence")
  
  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  if(model$converged==FALSE){stop("model did not coverge")}
  cat(sprintf("QIC for plan %s = %.1f\n", plan_names[i], as.numeric(MuMIn::QIC(model))))
  geem_strata_alt_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- model
}
```


```{r}
invisible("Alternative, worst model of strata")
```

#### 3.4.2 Stratifying, alt weight, GEEM Negative binomial 

Define a sequence of x values

```{r}
x_values <- seq(158e4, 159e4, by = 100)
```

Initialize a list to store models and their QICs

```{r}
geem2_strata_alt_alt_wgt_list <- list()
```

Loop over each unique plan name to fit models

```{r gee342, warning=T, echo=T, error=F, eval=T}
#| class-output: center-table

for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_proc2exp_iiw_strata_alt_alt, tipo_de_plan_2_mod == plan_names[i])
  
  # Initialize variable to store the best QIC and associated model
  best_qic <- Inf
  best_model <- NULL
  best_x <- NA
  
  # Loop through each x value to find the one with the lowest QIC
  for (x in x_values) {
    # Fit the GEE model for the current subset using geem with negative binomial
    model <- geem(tr_outcome ~ policonsumo2 +
                    comp_bpsc_y3_severe+
                    edad_al_ing_1 + 
                    ano_nac_corr + 
                    susinidumrec_otr +
                    susinidumrec_coc +
                    susinidumrec_pbc +
                    susinidumrec_mar +
                    psycom_dum_study +
                    psycom_dum_with +
                    freq_cons_dum_5day +
                    cond_oc_dum_2inact +
                    cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, 
                  id = id, 
                  data = current_data,
                  weight = current_data$iiw_strata_st,
                  family = MASS::negative.binomial(x),
                  corstr = "independence")
    
    if (model$converged) {
      # Calculate QIC for the model
      model_qic <- MuMIn::QIC(model)
      
      # Check if this model has a better QIC
      if (model_qic < best_qic) {
        best_qic <- model_qic
        best_model <- model
        best_x <- x
      }
    }
  }
  
  # Store the best model and its details in the list
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  geem2_strata_alt_alt_wgt_list[[paste("model", model_name, sep = "_")]] <- list(best_model = best_model, best_x = best_x, best_qic = best_qic)
  
  # Optional: Print out some information on progress
  cat(sprintf("Best QIC for plan %s with x = %.1f: %f\n", plan_names[i], best_x, best_qic))
}
```


Check the result for a particular plan

```{r}
#| class-output: center-table

print(geem2_strata_alt_alt_wgt_list[[1]])
```


# Model output

```{r output-gee}
#| class-output: center-table
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true


types_of_model<-
  c("No time-varying coefficients, no weight",
    "No time-varying coefficients, lag=0",
    "No time-varying coefficients, lag=1",
    "With time-varying coefficients, no weight",
    "With time-varying coefficients, lag=0",
    "With time-varying coefficients, lag=1",
    "Stratified by follow-up intervals, no weight",
    "Stratified by follow-up intervals, lag=0",
    "Stratified by follow-up intervals, lag=1",
    "Stratified by follow-up intervals, 2nd, lag=0"
)
types_of_model2<-
  c("No time-varying coefficients, no weight",
    "No time-varying coefficients, no weight, NB",
    "No time-varying coefficients, lag=0",
    "No time-varying coefficients, lag=0, NB",
    "No time-varying coefficients, lag=1",
    "No time-varying coefficients, lag=1, NB",
    "With time-varying coefficients, no weight",
    "With time-varying coefficients, no weight, NB",
    "With time-varying coefficients, lag=0",
    "With time-varying coefficients, lag=0, NB",
    "With time-varying coefficients, lag=1",
    "With time-varying coefficients, lag=1, NB",
    "Stratified by follow-up intervals, no weight",
    "Stratified by follow-up intervals, no weight, NB",
    "Stratified by follow-up intervals, lag=0",
    "Stratified by follow-up intervals, lag=0, NB",
    "Stratified by follow-up intervals, lag=1",
    "Stratified by follow-up intervals, lag=1, NB",
    "Stratified by follow-up intervals, 2nd, lag=1",
    "Stratified by follow-up intervals, 2nd, lag=1, NB"    
  )

plan_names[1]
cbind.data.frame(model= types_of_model,
rbind.data.frame(
dplyr::filter(tidy_geese_model(nocorr_nowgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(nocorr_wgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(nocorr_alt_wgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(afterph_nowgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(afterph_wgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(afterph_alt_wgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(strata_nowgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(strata_wgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(strata_alt_wgt_list[[1]]), Term=="policonsumo2"),
dplyr::filter(tidy_geese_model(strata_alt_alt_wgt_list[[1]]), Term=="policonsumo2")))%>% 
  {
    copiar_nombres2(.)
    assign(paste0("result_data_geese_", gsub(" ","_",plan_names[1])), ., envir = .GlobalEnv)
    print(.)
  }

cbind.data.frame(model= types_of_model2,
     QIC= c(as.numeric(QIC(geem_nocorr_nowgt_list[[1]])),
            as.numeric(geem2_nocorr_nowgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_nocorr_wgt_list[[1]])),
            as.numeric(geem2_nocorr_wgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_nocorr_alt_wgt_list[[1]])),
            as.numeric(geem2_nocorr_alt_wgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_afterph_nowgt_list[[1]])),
            as.numeric(geem2_afterph_nowgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_afterph_wgt_list[[1]])),
            as.numeric(geem2_afterph_wgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_afterph_alt_wgt_list[[1]])),
            as.numeric(geem2_afterph_alt_wgt_list[[1]]$best_qic),
            
            as.numeric(QIC(geem_strata_nowgt_list[[1]])),
            as.numeric(geem2_strata_nowgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_strata_wgt_list[[1]])),
            as.numeric(geem2_strata_wgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_strata_alt_wgt_list[[1]])),
            as.numeric(geem2_strata_alt_wgt_list[[1]]$best_qic),
            as.numeric(QIC(geem_strata_alt_alt_wgt_list[[1]])),
            as.numeric(geem2_strata_alt_alt_wgt_list[[1]]$best_qic)                        
            ),
     rbind.data.frame(
       dplyr::filter(summary2.geem(geem_nocorr_nowgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_nocorr_nowgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem_nocorr_wgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_nocorr_wgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem_nocorr_alt_wgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_nocorr_alt_wgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem_afterph_nowgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_afterph_nowgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem_afterph_wgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_afterph_wgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem_afterph_alt_wgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_afterph_alt_wgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       
       dplyr::filter(summary2.geem(geem_strata_nowgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_strata_nowgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),                   
       dplyr::filter(summary2.geem(geem_strata_wgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_strata_wgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem_strata_alt_wgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_strata_alt_wgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem_strata_alt_alt_wgt_list[[1]],exponentiate=T, digits=2),Term=="policonsumo2"),
       dplyr::filter(summary2.geem(geem2_strata_alt_alt_wgt_list[[1]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2")
       ))%>% 
  {
    copiar_nombres2(.)
    assign(paste0("result_data_geem_", gsub(" ","_",plan_names[1])), ., envir = .GlobalEnv)
    print(.)
  }

i=2
plan_names[i]
cbind.data.frame(model= types_of_model,
rbind.data.frame(
  dplyr::filter(tidy_geese_model(nocorr_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_alt_wgt_list[[i]]), Term=="policonsumo2")))%>% 
  {
    copiar_nombres2(.)  
    print(.)
  }

#[1] "GP intensive ambulatory". significativo
cbind.data.frame(model= types_of_model2,
         QIC= c(as.numeric(QIC(geem_nocorr_nowgt_list[[i]])),
                as.numeric(geem2_nocorr_nowgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_nocorr_wgt_list[[i]])),
                as.numeric(geem2_nocorr_wgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_nocorr_alt_wgt_list[[i]])),
                as.numeric(geem2_nocorr_alt_wgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_afterph_nowgt_list[[i]])),
                as.numeric(geem2_afterph_nowgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_afterph_wgt_list[[i]])),
                as.numeric(geem2_afterph_wgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_afterph_alt_wgt_list[[i]])),
                as.numeric(geem2_afterph_alt_wgt_list[[i]]$best_qic),
                
                as.numeric(QIC(geem_strata_nowgt_list[[i]])),
                as.numeric(geem2_strata_nowgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_strata_wgt_list[[i]])),
                as.numeric(geem2_strata_wgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_strata_alt_wgt_list[[i]])),
                as.numeric(geem2_strata_alt_wgt_list[[i]]$best_qic),
                as.numeric(QIC(geem_strata_alt_alt_wgt_list[[i]])),
                as.numeric(geem2_strata_alt_alt_wgt_list[[i]]$best_qic)                        
         ),
         rbind.data.frame(
           dplyr::filter(summary2.geem(geem_nocorr_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_nocorr_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem_nocorr_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_nocorr_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem_nocorr_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_nocorr_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem_afterph_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_afterph_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem_afterph_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_afterph_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem_afterph_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_afterph_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           
           dplyr::filter(summary2.geem(geem_strata_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_strata_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),                   
           dplyr::filter(summary2.geem(geem_strata_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_strata_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem_strata_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_strata_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem_strata_alt_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
           dplyr::filter(summary2.geem(geem2_strata_alt_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2")
         ))%>% 
  {
    copiar_nombres2(.)
    assign(paste0("result_data_geem_", gsub(" ","_",plan_names[i])), ., envir = .GlobalEnv)
    print(.)
  }


i=3
plan_names[i]
cbind.data.frame(model= types_of_model,
rbind.data.frame(
  dplyr::filter(tidy_geese_model(nocorr_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_alt_wgt_list[[i]]), Term=="policonsumo2"))) %>% 
  {
    copiar_nombres2(.)  
    print(.)
  }
cbind.data.frame(model= types_of_model2,
           QIC= c(as.numeric(QIC(geem_nocorr_nowgt_list[[i]])),
                  as.numeric(geem2_nocorr_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_nocorr_wgt_list[[i]])),
                  as.numeric(geem2_nocorr_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_nocorr_alt_wgt_list[[i]])),
                  as.numeric(geem2_nocorr_alt_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_nowgt_list[[i]])),
                  as.numeric(geem2_afterph_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_wgt_list[[i]])),
                  as.numeric(geem2_afterph_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_alt_wgt_list[[i]])),
                  as.numeric(geem2_afterph_alt_wgt_list[[i]]$best_qic),
                  
                  as.numeric(QIC(geem_strata_nowgt_list[[i]])),
                  as.numeric(geem2_strata_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_wgt_list[[i]])),
                  as.numeric(geem2_strata_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_alt_wgt_list[[i]])),
                  as.numeric(geem2_strata_alt_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_alt_alt_wgt_list[[i]])),
                  as.numeric(geem2_strata_alt_alt_wgt_list[[i]]$best_qic)                        
           ),
           rbind.data.frame(
             dplyr::filter(summary2.geem(geem_nocorr_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_nocorr_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_nocorr_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             
             dplyr::filter(summary2.geem(geem_strata_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),                   
             dplyr::filter(summary2.geem(geem_strata_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_strata_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_strata_alt_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_alt_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2")
           ))%>% 
  {
    copiar_nombres2(.)
    assign(paste0("result_data_geem_", gsub(" ","_",plan_names[i])), ., envir = .GlobalEnv)
    print(.)
  }


i=4
plan_names[i]
cbind.data.frame(model= types_of_model,
rbind.data.frame(
  dplyr::filter(tidy_geese_model(nocorr_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_alt_wgt_list[[i]]), Term=="policonsumo2"))) %>% 
  {
    copiar_nombres2(.)  
    print(.)
  }
cbind.data.frame(model= types_of_model2,
           QIC= c(as.numeric(QIC(geem_nocorr_nowgt_list[[i]])),
                  as.numeric(geem2_nocorr_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_nocorr_wgt_list[[i]])),
                  as.numeric(geem2_nocorr_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_nocorr_alt_wgt_list[[i]])),
                  as.numeric(geem2_nocorr_alt_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_nowgt_list[[i]])),
                  as.numeric(geem2_afterph_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_wgt_list[[i]])),
                  as.numeric(geem2_afterph_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_alt_wgt_list[[i]])),
                  as.numeric(geem2_afterph_alt_wgt_list[[i]]$best_qic),
                  
                  as.numeric(QIC(geem_strata_nowgt_list[[i]])),
                  as.numeric(geem2_strata_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_wgt_list[[i]])),
                  as.numeric(geem2_strata_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_alt_wgt_list[[i]])),
                  as.numeric(geem2_strata_alt_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_alt_alt_wgt_list[[i]])),
                  as.numeric(geem2_strata_alt_alt_wgt_list[[i]]$best_qic)                        
           ),
           rbind.data.frame(
             dplyr::filter(summary2.geem(geem_nocorr_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_nocorr_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_nocorr_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             
             dplyr::filter(summary2.geem(geem_strata_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),                   
             dplyr::filter(summary2.geem(geem_strata_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_strata_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_strata_alt_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_alt_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2")
           ))%>% 
  {
    copiar_nombres2(.)
    assign(paste0("result_data_geem_", gsub(" ","_",plan_names[i])), ., envir = .GlobalEnv)
    print(.)
  }

i=5
plan_names[i]
cbind.data.frame(model= types_of_model,
rbind.data.frame(
  dplyr::filter(tidy_geese_model(nocorr_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(nocorr_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(afterph_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_nowgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_wgt_list[[i]]), Term=="policonsumo2"),
  dplyr::filter(tidy_geese_model(strata_alt_alt_wgt_list[[i]]), Term=="policonsumo2"))) %>% 
  {
        copiar_nombres2(.)  
        print(.)
  }
  
cbind.data.frame(model= types_of_model2,
           QIC= c(as.numeric(QIC(geem_nocorr_nowgt_list[[i]])),
                  as.numeric(geem2_nocorr_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_nocorr_wgt_list[[i]])),
                  as.numeric(geem2_nocorr_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_nocorr_alt_wgt_list[[i]])),
                  as.numeric(geem2_nocorr_alt_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_nowgt_list[[i]])),
                  as.numeric(geem2_afterph_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_wgt_list[[i]])),
                  as.numeric(geem2_afterph_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_afterph_alt_wgt_list[[i]])),
                  as.numeric(geem2_afterph_alt_wgt_list[[i]]$best_qic),
                  
                  as.numeric(QIC(geem_strata_nowgt_list[[i]])),
                  as.numeric(geem2_strata_nowgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_wgt_list[[i]])),
                  as.numeric(geem2_strata_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_alt_wgt_list[[i]])),
                  as.numeric(geem2_strata_alt_wgt_list[[i]]$best_qic),
                  as.numeric(QIC(geem_strata_alt_alt_wgt_list[[i]])),
                  as.numeric(geem2_strata_alt_alt_wgt_list[[i]]$best_qic)                        
           ),
           rbind.data.frame(
             dplyr::filter(summary2.geem(geem_nocorr_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_nocorr_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_nocorr_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_nocorr_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_afterph_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_afterph_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             
             dplyr::filter(summary2.geem(geem_strata_nowgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_nowgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),                   
             dplyr::filter(summary2.geem(geem_strata_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_strata_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem_strata_alt_alt_wgt_list[[i]],exponentiate=T, digits=2),Term=="policonsumo2"),
             dplyr::filter(summary2.geem(geem2_strata_alt_alt_wgt_list[[i]]$best_model,exponentiate=T, digits=2),Term=="policonsumo2")
           ))%>% 
  {
    copiar_nombres2(.)
    assign(paste0("result_data_geem_", gsub(" ","_",plan_names[i])), ., envir = .GlobalEnv)
    print(.)
  }


rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                 cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                 cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
                 ) %>% 
  dplyr::group_by(setting) %>% 
  dplyr::mutate(min_qic_setting=ifelse(QIC==min(QIC),1,0)) %>% 
  dplyr::mutate(QIC= format(as.numeric(sprintf("%1.1f",QIC)), big.mark=",")) %>% 
  dplyr::ungroup() %>%
  dplyr::mutate(`RR (95% IC)`= paste0(Estimates, " (", `CI.lower`, ", ", CI.upper, ")")) %>% 
  dplyr::select(setting, model, QIC, `RR (95% IC)`, p.value) %>% 
  {
  #copiar_nombres2()
    write.table(., file = paste0(folder_path,"gee_240515.csv"), dec=",", sep="\t")
    knitr::kable(., size=10, format="html", caption="Relative risk of treatment non-completion status by reported polysubstance use") %>% 
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
    kableExtra::scroll_box(width = "100%", height = "375px")  
  }
```


# Stratifying by presence of alcohol among poly-substance use

```{r}

data_mine_miss_restr_proc2exp2<-
  data_mine_miss_restr_proc2 %>% 
  left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","n_off_acq","n_off_vio","n_off_sud","n_off_oth", "n_prev_off")], by="hash_key") %>%
  tidylog::left_join(Base_fiscalia_v15f_grant_23_24[,c("hash_key","fech_ing_num","otras_sus1_mod","otras_sus2_mod","otras_sus3_mod")], by=c("hash_key"="hash_key","fech_ing_num"="fech_ing_num")) %>% 
  {if (nrow(.) > nrow(data_mine_miss_restr_proc2)) {message("left join added rows"); .} else .} %>% 
  dplyr::mutate(n_prev_off_bin= ifelse(n_prev_off>0,1,0)) %>% 
  dplyr::mutate(
    susinidumrec_coc = ifelse(sus_ini_mod_mvv == "Cocaine hydrochloride", 1, 0),
    susinidumrec_pbc = ifelse(sus_ini_mod_mvv == "Cocaine paste", 1, 0),
    susinidumrec_mar = ifelse(sus_ini_mod_mvv == "Marijuana", 1, 0),
    susinidumrec_otr = ifelse(sus_ini_mod_mvv == "Other", 1, 0), #sus_principal_mod
    susprindumrec_coc = ifelse(sus_principal_mod == "Cocaine hydrochloride", 1, 0),
    susprindumrec_pbc = ifelse(sus_principal_mod == "Cocaine paste", 1, 0),
    susprindumrec_mar = ifelse(sus_principal_mod == "Marijuana", 1, 0),
    susprindumrec_otr = ifelse(sus_principal_mod == "Other", 1, 0) # "susprindum_coc", "susprindum_pbc", "susprindum_mar", "susprindum_oh
  ) %>% 
  rowwise() %>%
  #Condition
  dplyr::mutate(oh_otras_sus = if_else("Alcohol" %in% c(otras_sus1_mod, otras_sus2_mod, otras_sus3_mod),1,0)) %>%
  dplyr::mutate(policonsumo2_rec= dplyr::case_when(policonsumo2==1 & oh_otras_sus==1~"2.both",policonsumo2==1 & oh_otras_sus==0~"1.only PSU",T~"0.no PSU")) %>% 
  ungroup()

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#

nocorr_nowgt_int_list<-list()
nocorr_nowgt_int_probs_list<-list()
nocor_nowgt_int_tab <-list()
for (i in seq_along(plan_names)) {
  # Subset the data for the current plan type
  current_data <- subset(data_mine_miss_restr_proc2exp2, tipo_de_plan_2_mod == plan_names[i])
  
  # Fit the GEE model for the current subset
  model <- geeglm(tr_outcome ~ policonsumo2_rec +
                   comp_bpsc_y3_severe+
                   edad_al_ing_1 + 
                   ano_nac_corr + 
                   susinidumrec_otr +
                   susinidumrec_coc +
                   susinidumrec_pbc +
                   susinidumrec_mar +
                   psycom_dum_study +
                   psycom_dum_with +
                   freq_cons_dum_5day +
                   cond_oc_dum_2inact +
                   cond_oc_dum_3unemp +
                   susprindumrec_coc +
                   susprindumrec_pbc +
                   susprindumrec_mar +
                   susprindumrec_otr, #origen_ingreso_mod fis_comorbidity_icd_10 dg_trs_cons_sus_or
                 id = id, 
                 data = current_data,
                 family = poisson, 
                 corstr = "independence")

  # Assign the model to the list with a name based on the plan name
  model_name <- gsub(" ", "_", plan_names[i])
  model_name <- gsub("[^[:alnum:]_]", "", model_name)  # Clean up non-alphanumeric characters
  
  nocor_nowgt_int_tab[[paste0("tab_", model_name)]] <- table(current_data$policonsumo2_rec, current_data$tr_outcome) %>% data.frame()
  nocorr_nowgt_int_list[[paste("model", model_name, sep = "_")]] <- model
  emmeans_response <- emmeans(model, ~policonsumo2_rec,  rg.limit=2e5, type = "response")
  nocorr_nowgt_int_probs_list[[paste0("emmeans_response_int_", model_name)]] <- emmeans_response
  assign(paste0("emmeans_response_int_", model_name), emmeans_response, envir = .GlobalEnv)
}

nocor_nowgt_int_tab[1]
nocor_nowgt_int_tab[2]
nocor_nowgt_int_tab[3]
nocor_nowgt_int_tab[4]
nocor_nowgt_int_tab[5]

# > nocor_nowgt_int_tab[1]
# $tab_basic_ambulatory
# Var1 Var2 Freq
# 1   0.no PSU    0  629
# 2 1.only PSU    0 1210
# 3     2.both    0  286
# 4   0.no PSU    1 1827
# 5 1.only PSU    1 4450
# 6     2.both    1 1591
# 
# > nocor_nowgt_int_tab[2]
# $tab_GP_intensive_ambulatory
# Var1 Var2 Freq
# 1   0.no PSU    0  624
# 2 1.only PSU    0 1615
# 3     2.both    0  401
# 4   0.no PSU    1 1573
# 5 1.only PSU    1 5226
# 6     2.both    1 2058
# 
# > nocor_nowgt_int_tab[3]
# $tab_GP_residential
# Var1 Var2 Freq
# 1   0.no PSU    0  261
# 2 1.only PSU    0  905
# 3     2.both    0  400
# 4   0.no PSU    1  572
# 5 1.only PSU    1 2360
# 6     2.both    1  706
# 
# > nocor_nowgt_int_tab[4]
# $tab_WO_intensive_ambulatory
# Var1 Var2 Freq
# 1   0.no PSU    0  110
# 2 1.only PSU    0  253
# 3     2.both    0   61
# 4   0.no PSU    1  292
# 5 1.only PSU    1  726
# 6     2.both    1  318
# 
# > nocor_nowgt_int_tab[5]
# $tab_WO_residential
# Var1 Var2 Freq
# 1   0.no PSU    0  172
# 2 1.only PSU    0  413
# 3     2.both    0  130
# 4   0.no PSU    1  289
# 5 1.only PSU    1 1147
# 6     2.both    1  383
# 
invisible("no hay tan pocos casos en un estrato, salvo en WO intensive ambulatory")



invisible("En el basic ambulatory, GP intensive-amb y GP residential, el sig es el ambos (consumo alcohol)")
  
#broom::tidy(nocorr_nowgt_int_list[[1]], exponentiate=T, conf.int=T)[1:3,] 
#    term                         estimate std.error statistic     p.value conf.low conf.high
#   <chr>                           <dbl>     <dbl>     <dbl>       <dbl>    <dbl>     <dbl>
# 1 (Intercept)                0.00000870    4.83       5.81  0.0159      6.68e-10     0.113
# 2 policonsumo2_rec1.only PSU 1.01          0.0143     0.488 0.485       9.82e- 1     1.04 
# 3 policonsumo2_rec2.both     1.08          0.0161    24.8   0.000000622 1.05e+ 0     1.12 

#broom::tidy(nocorr_nowgt_int_list[[2]], exponentiate=T, conf.int=T)[1:3,]
#   term                         estimate std.error statistic       p.value conf.low conf.high
#   <chr>                           <dbl>     <dbl>     <dbl>         <dbl>    <dbl>     <dbl>
# 1 (Intercept)                0.00000655    4.81        6.15 0.0132        5.23e-10    0.0822
# 2 policonsumo2_rec1.only PSU 1.02          0.0153      1.98 0.160         9.92e- 1    1.05  
# 3 policonsumo2_rec2.both     1.10          0.0162     35.1  0.00000000312 1.07e+ 0    1.14  

invisible("Aunque GP residential es protector el policonsumo en both")
#broom::tidy(nocorr_nowgt_int_list[[3]], exponentiate=T, conf.int=T)[1:3,]
#   term                       estimate std.error statistic  p.value     conf.low    conf.high
#   <chr>                         <dbl>     <dbl>     <dbl>    <dbl>        <dbl>        <dbl>
# 1 (Intercept)                   1.14     9.06    0.000199 0.989    0.0000000221 58484383.   
# 2 policonsumo2_rec1.only PSU    0.989    0.0275  0.175    0.676    0.937               1.04 
# 3 policonsumo2_rec2.both        0.885    0.0332 13.5      0.000243 0.830               0.945


invisible("En WO intensive ambulatory, no tira ninguno")

#broom::tidy(nocorr_nowgt_int_list[[4]], exponentiate=T, conf.int=T)[1:3,]
# # A tibble: 3 x 7
#   term                       estimate std.error statistic p.value conf.low  conf.high
#   <chr>                         <dbl>     <dbl>     <dbl>   <dbl>    <dbl>      <dbl>
# 1 (Intercept)                0.000318   12.0        0.452  0.501  2.02e-14 4991312.  
# 2 policonsumo2_rec1.only PSU 0.956       0.0357     1.62   0.203  8.91e- 1       1.02
# 3 policonsumo2_rec2.both     1.07        0.0376     3.13   0.0767 9.93e- 1       1.15
# 
invisible("En WO residential, ambos mueven la aguja a mayor riesgo")
# 
#broom::tidy(nocorr_nowgt_int_list[[5]], exponentiate=T, conf.int=T)[1:3,]
#   term                        estimate std.error statistic  p.value  conf.low conf.high
#   <chr>                          <dbl>     <dbl>     <dbl>    <dbl>     <dbl>     <dbl>
# 1 (Intercept)                249351.     11.6         1.15 0.284    0.0000331   1.88e15
# 2 policonsumo2_rec1.only PSU      1.14    0.0388     11.3  0.000775 1.06        1.23e 0
# 3 policonsumo2_rec2.both          1.14    0.0439      8.83 0.00297  1.05        1.24e 0
# 
# 
bind_rows(
    lapply(nocorr_nowgt_int_list[1:5], function(model) {
        broom::tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
            dplyr::select(term, estimate, conf.low, conf.high, p.value) %>%
        
            slice(2:3)
    }),
    .id = "model"
) %>% 
  dplyr::mutate(term= gsub("policonsumo2_","", term)) %>% 
  dplyr::mutate(across(c("estimate","conf.low", "conf.high"),~sprintf("%1.2f",.))) %>% 
  dplyr::mutate(RR= paste0(estimate, " (", conf.low,"-", conf.high,")")) %>% 
  dplyr::select(-estimate, -conf.low, -conf.high) %>% 
  dplyr::select(model, term, RR, p.value) %>% 
  dplyr::mutate(across(c("p.value"),~sprintf("%1.4f",.))) %>%
  {
  knitr::kable(., "markdown", caption= "Relative risk of treatment non-completion status by reported polysubstance use, whether ")
  }
```

```{r "fig-prev-psu-tr-noncomp", fig.align='center', paged.print=TRUE, fig.cap="Percentage distribution of treatment outcomes by treatment setting and polysubstance use status", results='hold'}
#| fig-width: 7
#| fig-height: 8.4
#| fig.showtext: true

# bind_rows(
#   lapply(1:5, function(model) {
#     nocor_nowgt_int_tab[[model]]%>% dplyr::mutate(Var0=ifelse(grepl("no PSU",Var1),1,0)) %>% dplyr::group_by(Var0, Var2) %>% dplyr::summarise(n= sum(Freq))
#   }),
#   .id = "model"
# ) %>% 
#   group_by(model) %>% 
#   summarise(n=sum(n))

bind_rows(
  lapply(1:5, function(model) {
    nocor_nowgt_int_tab[[model]]%>% dplyr::mutate(Var0=ifelse(grepl("no PSU",Var1),1,0)) %>% dplyr::group_by(Var0, Var2) %>% dplyr::summarise(n= sum(Freq))
  }),
  .id = "model"
) %>% 
  dplyr::mutate(Var0= ifelse(Var0==1,"PSU", "no PSU")) %>% 
  group_by(model, Var0) %>%
  mutate(percentage = n / sum(n)) %>% 
  dplyr::ungroup() %>% 
  ggplot(aes(x = factor(Var0), y = percentage, fill = factor(Var2))) +
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ model, ncol = 1, labeller = labeller(model = c(
    "1" = "Basic ambulatory (n= 9,993)",
    "2" = "General-population, intensive ambulatory (n= 11,497)",
    "3" = "General-population, residential (n= 5,204)",
    "4" = "Women-only,intensive ambulatory (n= 1,760)",
    "5" = "Women-only, residential (n= 2,534)"
  )), strip.position = "top") +
  scale_fill_manual(values = c("grey60", "grey20"), label=c("Treatment completion", "Treatment non-completion")) +
  labs(x = "Polysubstance use (PSU)", y = "Percentage", fill = "Treatment outcome") +
  scale_y_continuous(labels = scales::percent) +
  geom_text(aes(label = scales::percent(percentage, accuracy = 0.1)), 
            position = position_stack(vjust = 0.5), size = 3.5, color = "white") +
  theme_minimal() +
  theme(
    strip.text = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    text = element_text(family = "Times New Roman"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    strip.text.x = element_text(angle = 0, hjust = 0.5, size = 12, face = "bold"),
    strip.background = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "bottom"
  )
ggsave("E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/_figs/barplot2.png", height=12*.7, width=10*.7, dpi=500)
ggsave("E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/_figs/barplot2.jpg", height=12*.7, width=10*.7, dpi=500)

#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#
nocorr_nowgt_int2_list<-
bind_rows(
  lapply(nocorr_nowgt_int_list[1:5], function(model) {
    broom::tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
      dplyr::select(term, estimate, std.error, conf.low, conf.high, p.value) %>%
      dplyr::mutate(log_rr= log(estimate), log_lcl= log(conf.low), log_ucl= log(conf.high), variance= ((log_ucl-log_rr)/qnorm(0.975))^2)%>% 
      dplyr::slice(2:3)
  }),
  .id = "model"
)

log_rr_int<- nocorr_nowgt_int2_list$log_rr  
variances_int<- nocorr_nowgt_int2_list$variance  


results_int <- expand.grid(i=1:5, j=1:5) %>%
  filter(i < j) %>%
  mutate(
    drrr = log_rr_int[i] - log_rr_int[j],
    var_drrr = variances_int[i] + variances_int[j],
    se_drrr = sqrt(var_drrr),
    z_value = drrr / se_drrr,
    p_value = 2 * (1 - pnorm(abs(z_value))),
    ratio_estimates = exp(drrr),
    lower_bound = exp(drrr - qnorm(0.975) * se_drrr),
    upper_bound = exp(drrr + qnorm(0.975) * se_drrr)
  ) %>% 
  dplyr::mutate(i= dplyr::case_when(i==1~plan_names[1], i==2~plan_names[2], 
                i==3~plan_names[3], i==4~plan_names[4], i==5~plan_names[5]), 
                j= dplyr::case_when(j==1~plan_names[1], j==2~plan_names[2], 
                j==3~plan_names[3], j==4~plan_names[4], j==5~plan_names[5]))
```


# Marginal probabilities

Loop over each unique plan name to fit a model. We used an interaction of PSU and treatment setting to capture the heterogeneity of PSU by treatment setting.

```{r output-marginal-emmeans}
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true


df_marginal_plots<-
  cbind.data.frame(wgt= c("wgt", "iiw_nocorr_st", "iiw_nocorr_alt_st", "wgt", "iiw_after_ph_st", "iiw_after_ph_st"), 
        df= c("data_mine_miss_restr_proc2exp","data_mine_miss_restr_proc2exp","data_mine_miss_restr_proc2exp","data_mine_miss_restr_proc2exp_iiw_after_ph","data_mine_miss_restr_proc2exp_iiw_after_ph","data_mine_miss_restr_proc2exp_iiw_after_ph_alt"),
        model= c("no corr no wgt","no corr main","no corr alt", "after ph no wgt", "after ph main", "after ph alt"))

# Loop over each unique plan name to fit a model
for (i in seq_along(df_marginal_plots$wgt)) {
  # Subset the data for the current plan type
  #current_data <- subset(data_mine_miss_restr_proc2, tipo_de_plan_2_mod == plan_names[i])
  geeglm( tr_outcome  ~ policonsumo2 * tipo_de_plan_2_mod +
                        edad_al_ing_1 + 
                        ano_nac_corr + 
                        susinidumrec_otr +
                        susinidumrec_coc +
                        susinidumrec_pbc +
                        susinidumrec_mar +
                        psycom_dum_study +
                        psycom_dum_with +
                        freq_cons_dum_5day +
                        cond_oc_dum_2inact +
                        cond_oc_dum_3unemp +
                       susprindumrec_coc +
                       susprindumrec_pbc +
                       susprindumrec_mar +
                       susprindumrec_otr, 
                    id= id, 
                    data= get(df_marginal_plots$df[i]) %>% dplyr::mutate(wgt=1), 
                    weight= get(df_marginal_plots$df[i]) %>% dplyr::mutate(wgt=1) %>% pull(df_marginal_plots$wgt[i]), 
                    family= poisson, 
                    corstr= "independence") %>% 
  assign(paste0("geeglm_", gsub(" ","_",df_marginal_plots$model[i])), ., envir = .GlobalEnv)
  print(message(paste0("Models: ",paste0("geeglm_", gsub(" ","_",df_marginal_plots$model[i])))))
  emmeans_response <- emmeans(get(paste0("geeglm_", gsub(" ","_",df_marginal_plots$model[i]))), ~policonsumo2+tipo_de_plan_2_mod,  rg.limit=2e5, type = "response")%>% assign(paste0("emmeans_response_", gsub(" ","_",df_marginal_plots$model[i])), ., envir = .GlobalEnv)
  print(message(paste0("Emmeans: ",paste0("emmeans_response_", gsub(" ","_",df_marginal_plots$model[i])))))
}
```


```{r output-marginal-emmeans-plot, fig.align="center", dpi=300}
#| class-output: center-table
#| message: false
#| include: true
#| warning: true
#| error: false
#| eval: true
#| fig.showtext: true

plot(emmeans_response_no_corr_no_wgt)+ ggtitle("No corr, no weights")#+ geom_point(aes(x = percent, y = conc), data = pigs, pch = 2, color = "blue")
plot(emmeans_response_no_corr_main)+ ggtitle("No corr, main weights")
plot(emmeans_response_no_corr_alt)+ ggtitle("No corr, alt weights")
plot(emmeans_response_after_ph_no_wgt)+ ggtitle("After PH, no weights")
plot(emmeans_response_after_ph_main)+ ggtitle("After PH, main weights")
plot(emmeans_response_after_ph_alt)+ ggtitle("After PH, alt weights")
```

# Heterogeneity

```{r heterogeneity}
#| message: false
#| include: true
#| warning: false
#| error: false
#| eval: true

library(meta)
try(library(dmetar))
library(metafor)


#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
##_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
##
# Define los valores de los Relative Risk Reductions (RRR) y sus intervalos de confianza
rrr <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                 cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                 cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, no weight") %>% pull(`Estimates`) %>% as.numeric()
lcl <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                 cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                 cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, no weight") %>% pull(`CI.lower`) %>% as.numeric()
ucl <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                 cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                 cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, no weight") %>% pull(`CI.upper`) %>% as.numeric()


# Calcula los logaritmos de los RRR y de los límites de sus intervalos de confianza
log_rrr <- log(rrr)
log_lcl <- log(lcl)
log_ucl <- log(ucl)

# Calcula las varianzas
variances <- ((log_ucl - log_rrr) / qnorm(0.975))^2

# Meta-análisis usando un modelo de efectos aleatorios
meta_analysis <- rma(yi=log_rrr, sei=sqrt(variances), method="REML")

# Prueba de Cochran Q para evaluar la heterogeneidad
cochrans_q <- meta_analysis$QE
p_value_q <- meta_analysis$QEp

cat(sprintf("No time-varying coefficients, no weight- Cochran's Q = %.2f, p-value = %.4f\n", cochrans_q, p_value_q))
#concuerda con el calculo de stata
#
#

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
##_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
###_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
###
###

# Define los valores de los Relative Risk Reductions (RRR) y sus intervalos de confianza
rrr2 <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                         cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                         cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                         cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                         cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, lag=0") %>% pull(`Estimates`) %>% as.numeric()
lcl2 <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                         cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                         cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                         cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                         cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, lag=0") %>% pull(`CI.lower`) %>% as.numeric()
ucl2 <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                         cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                         cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                         cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                         cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, lag=0") %>% pull(`CI.upper`) %>% as.numeric()


# Calcula los logaritmos de los RRR y de los límites de sus intervalos de confianza
log_rrr2 <- log(rrr2)
log_lcl2 <- log(lcl2)
log_ucl2 <- log(ucl2)

# Calcula las varianzas
variances2 <- ((log_ucl2 - log_rrr2) / qnorm(0.975))^2

# Meta-análisis usando un modelo de efectos aleatorios
meta_analysis2 <- rma(yi=log_rrr2, sei=sqrt(variances2), method="REML")

# Prueba de Cochran Q para evaluar la heterogeneidad
cochrans_q2 <- meta_analysis2$QE
p_value_q2 <- meta_analysis2$QEp

cat(sprintf("No time-varying coefficients, lag=0, main- Cochran's Q = %.2f, p-value = %.4f\n", cochrans_q2, p_value_q2))
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
##_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
###_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

# Define los valores de los Relative Risk Reductions (RRR) y sus intervalos de confianza
rrr3 <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                 cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                 cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, lag=1") %>% pull(`Estimates`) %>% as.numeric()
lcl3 <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                 cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                 cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, lag=1") %>% pull(`CI.lower`) %>% as.numeric()
ucl3 <- rbind.data.frame(cbind.data.frame(setting=plan_names[1],result_data_geem_basic_ambulatory),
                 cbind.data.frame(setting=plan_names[2],result_data_geem_GP_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[3],result_data_geem_GP_residential),
                 cbind.data.frame(setting=plan_names[4],result_data_geem_WO_intensive_ambulatory),
                 cbind.data.frame(setting=plan_names[5],result_data_geem_WO_residential)
) %>% 
    dplyr::group_by(setting) %>% 
    dplyr::filter(model=="No time-varying coefficients, lag=1") %>% pull(`CI.upper`) %>% as.numeric()


# Calcula los logaritmos de los RRR y de los límites de sus intervalos de confianza
log_rrr3 <- log(rrr3)
log_lcl3 <- log(lcl3)
log_ucl3 <- log(ucl3)

# Calcula las varianzas
variances3 <- ((log_ucl3 - log_rrr3) / qnorm(0.975))^2

# Meta-análisis usando un modelo de efectos aleatorios
meta_analysis3 <- rma(yi=log_rrr3, sei=sqrt(variances3), method="REML")

# Prueba de Cochran Q para evaluar la heterogeneidad
cochrans_q3 <- meta_analysis3$QE
p_value_q3 <- meta_analysis3$QEp

cat(sprintf("No time-varying coefficients, lag=1- Cochran's Q = %.2f, p-value = %.4f\n", cochrans_q3, p_value_q3))

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
##_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
###_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
###

# Comparaciones de Altman para todas las combinaciones de RRR
results <- expand.grid(i=1:5, j=1:5) %>%
  filter(i < j) %>%
  mutate(
    drrr = log_rrr[i] - log_rrr[j],
    var_drrr = variances[i] + variances[j],
    se_drrr = sqrt(var_drrr),
    z_value = drrr / se_drrr,
    p_value = 2 * (1 - pnorm(abs(z_value))),
    ratio_estimates = exp(drrr),
    lower_bound = exp(drrr - qnorm(0.975) * se_drrr),
    upper_bound = exp(drrr + qnorm(0.975) * se_drrr)
  ) %>% 
  dplyr::mutate(i= dplyr::case_when(i==1~plan_names[1], i==2~plan_names[2], i==3~plan_names[3], i==4~plan_names[4], i==5~plan_names[5]), j= dplyr::case_when(j==1~plan_names[1], j==2~plan_names[2], j==3~plan_names[3], j==4~plan_names[4], j==5~plan_names[5]))

results2 <- expand.grid(i=1:5, j=1:5) %>%
  filter(i < j) %>%
  mutate(
    drrr = log_rrr2[i] - log_rrr2[j],
    var_drrr = variances2[i] + variances2[j],
    se_drrr = sqrt(var_drrr),
    z_value = drrr / se_drrr,
    p_value = 2 * (1 - pnorm(abs(z_value))),
    ratio_estimates = exp(drrr),
    lower_bound = exp(drrr - qnorm(0.975) * se_drrr),
    upper_bound = exp(drrr + qnorm(0.975) * se_drrr)
  ) %>% 
  dplyr::mutate(i= dplyr::case_when(i==1~plan_names[1], i==2~plan_names[2], i==3~plan_names[3], i==4~plan_names[4], i==5~plan_names[5]), j= dplyr::case_when(j==1~plan_names[1], j==2~plan_names[2], j==3~plan_names[3], j==4~plan_names[4], j==5~plan_names[5]))

results3 <- expand.grid(i=1:5, j=1:5) %>%
  filter(i < j) %>%
  mutate(
    drrr = log_rrr3[i] - log_rrr3[j],
    var_drrr = variances3[i] + variances3[j],
    se_drrr = sqrt(var_drrr),
    z_value = drrr / se_drrr,
    p_value = 2 * (1 - pnorm(abs(z_value))),
    ratio_estimates = exp(drrr),
    lower_bound = exp(drrr - qnorm(0.975) * se_drrr),
    upper_bound = exp(drrr + qnorm(0.975) * se_drrr)
  ) %>% 
  dplyr::mutate(i= dplyr::case_when(i==1~plan_names[1], i==2~plan_names[2], i==3~plan_names[3], i==4~plan_names[4], i==5~plan_names[5]), j= dplyr::case_when(j==1~plan_names[1], j==2~plan_names[2], j==3~plan_names[3], j==4~plan_names[4], j==5~plan_names[5]))

# Imprime los resultados
#el 5 tiene el mayor efecto en omparación con el resto
#
bind_rows(cbind.data.frame(model= "No time-varying coefficients, no weight",results), 
                 cbind.data.frame(model= "No time-varying coefficients, lag=0",results2), 
                 cbind.data.frame(model= "No time-varying coefficients, lag=1",results3)
                 ) %>% 
  dplyr::mutate(across(c("drrr","var_drrr", "se_drrr", "z_value", "ratio_estimates", "lower_bound", "upper_bound"),~sprintf("%1.2f",.))) %>% 
  dplyr::mutate(across(c("p_value"),~sprintf("%1.4f",.))) %>% 
  dplyr::mutate(`rrr (95% IC)`= paste0(ratio_estimates, " (", lower_bound, ", ", upper_bound,")")) %>% 
  dplyr::select(-any_of(c("drrr", "var_drrr", "se_drrr", "z_value", "ratio_estimates", "lower_bound", "upper_bound"))) %>% 
  {
  #copiar_nombres2()
    write.table(., file = paste0(folder_path,"rr_contrasts_240625.csv"), dec=",", sep="\t")
    knitr::kable(., size=10, format="html", caption="GEE Models, Heterogeneity & contrasts by setting") %>% 
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
     kableExtra::scroll_box(width = "100%", height = "375px")  
  }
```



# Session info

```{r session-info, echo=T, error=T, message=TRUE, paged.print=TRUE,eval=T}
message(paste0("R library: ", Sys.getenv("R_LIBS_USER")))
message(paste0("Date: ",withr::with_locale(new = c('LC_TIME' = 'C'), code =Sys.time())))
message(paste0("Editor context: ", getwd()))
```


```{r session-info-r, echo=T, error=T, message=TRUE, paged.print=TRUE,eval=T}
#| class-output: center-table

sesion_info <- devtools::session_info()
dplyr::select(
  tibble::as_tibble(sesion_info$packages),
  c(package, loadedversion, source)
) %>% 
 knitr::kable(caption = "R packages", format = "html",
      col.names = c("Row number", "Package", "Version"),
    row.names = FALSE,
      align = c("c", "l", "r")) %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
  kableExtra::scroll_box(width = "100%", height = "375px")  
```


```{r session-info-python, echo=T, error=T, message=TRUE, paged.print=TRUE,eval=T}
#| class-output: center-table

reticulate::py_list_packages()%>% 
 knitr::kable(caption = "Python packages", format = "html",
      col.names = c("Package", "Version", "Requirement"),
    row.names = FALSE,
      align = c("c", "l", "r", "r"))%>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12) %>% 
  kableExtra::scroll_box(width = "100%", height = "375px")  
```


# Output 

```{r}
folder_path <- ifelse(dir.exists("E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/"),
                      "E:/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/",
                      "C:/Users/CISS Fondecyt/Mi unidad/Alvacast/SISTRAT 2022 (github)/_proposal_grant/2023/")
save.image(paste0(folder_path,"an_grant_23_24_4.RData"))
```